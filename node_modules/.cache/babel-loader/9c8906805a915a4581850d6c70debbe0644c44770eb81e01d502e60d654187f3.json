{"ast":null,"code":"import { Box3 } from './Box3.js';\nimport { Vector3 } from './Vector3.js';\nconst _box = /*@__PURE__*/new Box3();\nconst _v1 = /*@__PURE__*/new Vector3();\nconst _v2 = /*@__PURE__*/new Vector3();\nclass Sphere {\n  constructor(center = new Vector3(), radius = -1) {\n    this.isSphere = true;\n    this.center = center;\n    this.radius = radius;\n  }\n  set(center, radius) {\n    this.center.copy(center);\n    this.radius = radius;\n    return this;\n  }\n  setFromPoints(points, optionalCenter) {\n    const center = this.center;\n    if (optionalCenter !== undefined) {\n      center.copy(optionalCenter);\n    } else {\n      _box.setFromPoints(points).getCenter(center);\n    }\n    let maxRadiusSq = 0;\n    for (let i = 0, il = points.length; i < il; i++) {\n      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n    }\n    this.radius = Math.sqrt(maxRadiusSq);\n    return this;\n  }\n  copy(sphere) {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    return this;\n  }\n  isEmpty() {\n    return this.radius < 0;\n  }\n  makeEmpty() {\n    this.center.set(0, 0, 0);\n    this.radius = -1;\n    return this;\n  }\n  containsPoint(point) {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n  distanceToPoint(point) {\n    return point.distanceTo(this.center) - this.radius;\n  }\n  intersectsSphere(sphere) {\n    const radiusSum = this.radius + sphere.radius;\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  }\n  intersectsBox(box) {\n    return box.intersectsSphere(this);\n  }\n  intersectsPlane(plane) {\n    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n  clampPoint(point, target) {\n    const deltaLengthSq = this.center.distanceToSquared(point);\n    target.copy(point);\n    if (deltaLengthSq > this.radius * this.radius) {\n      target.sub(this.center).normalize();\n      target.multiplyScalar(this.radius).add(this.center);\n    }\n    return target;\n  }\n  getBoundingBox(target) {\n    if (this.isEmpty()) {\n      // Empty sphere produces empty bounding box\n      target.makeEmpty();\n      return target;\n    }\n    target.set(this.center, this.center);\n    target.expandByScalar(this.radius);\n    return target;\n  }\n  applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  }\n  translate(offset) {\n    this.center.add(offset);\n    return this;\n  }\n  expandByPoint(point) {\n    if (this.isEmpty()) {\n      this.center.copy(point);\n      this.radius = 0;\n      return this;\n    }\n    _v1.subVectors(point, this.center);\n    const lengthSq = _v1.lengthSq();\n    if (lengthSq > this.radius * this.radius) {\n      // calculate the minimal sphere\n\n      const length = Math.sqrt(lengthSq);\n      const delta = (length - this.radius) * 0.5;\n      this.center.addScaledVector(_v1, delta / length);\n      this.radius += delta;\n    }\n    return this;\n  }\n  union(sphere) {\n    if (sphere.isEmpty()) {\n      return this;\n    }\n    if (this.isEmpty()) {\n      this.copy(sphere);\n      return this;\n    }\n    if (this.center.equals(sphere.center) === true) {\n      this.radius = Math.max(this.radius, sphere.radius);\n    } else {\n      _v2.subVectors(sphere.center, this.center).setLength(sphere.radius);\n      this.expandByPoint(_v1.copy(sphere.center).add(_v2));\n      this.expandByPoint(_v1.copy(sphere.center).sub(_v2));\n    }\n    return this;\n  }\n  equals(sphere) {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nexport { Sphere };","map":{"version":3,"names":["Box3","Vector3","_box","_v1","_v2","Sphere","constructor","center","radius","isSphere","set","copy","setFromPoints","points","optionalCenter","undefined","getCenter","maxRadiusSq","i","il","length","Math","max","distanceToSquared","sqrt","sphere","isEmpty","makeEmpty","containsPoint","point","distanceToPoint","distanceTo","intersectsSphere","radiusSum","intersectsBox","box","intersectsPlane","plane","abs","clampPoint","target","deltaLengthSq","sub","normalize","multiplyScalar","add","getBoundingBox","expandByScalar","applyMatrix4","matrix","getMaxScaleOnAxis","translate","offset","expandByPoint","subVectors","lengthSq","delta","addScaledVector","union","equals","setLength","clone"],"sources":["C:/Users/21064/Desktop/frontend/node_modules/three/src/math/Sphere.js"],"sourcesContent":["import { Box3 } from './Box3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _box = /*@__PURE__*/ new Box3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\tthis.isSphere = true;\n\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.center.copy( point );\n\n\t\t\tthis.radius = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_v1.subVectors( point, this.center );\n\n\t\tconst lengthSq = _v1.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t// calculate the minimal sphere\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\n\t\t\tconst delta = ( length - this.radius ) * 0.5;\n\n\t\t\tthis.center.addScaledVector( _v1, delta / length );\n\n\t\t\tthis.radius += delta;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunion( sphere ) {\n\n\t\tif ( sphere.isEmpty() ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.copy( sphere );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.center.equals( sphere.center ) === true ) {\n\n\t\t\t this.radius = Math.max( this.radius, sphere.radius );\n\n\t\t} else {\n\n\t\t\t_v2.subVectors( sphere.center, this.center ).setLength( sphere.radius );\n\n\t\t\tthis.expandByPoint( _v1.copy( sphere.center ).add( _v2 ) );\n\n\t\t\tthis.expandByPoint( _v1.copy( sphere.center ).sub( _v2 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nexport { Sphere };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}