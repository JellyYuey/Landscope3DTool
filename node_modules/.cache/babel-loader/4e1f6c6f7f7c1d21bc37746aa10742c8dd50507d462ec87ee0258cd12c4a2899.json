{"ast":null,"code":"import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { arrayNeedsUint32 } from '../utils.js';\nlet _id = 0;\nconst _m1 = /*@__PURE__*/new Matrix4();\nconst _obj = /*@__PURE__*/new Object3D();\nconst _offset = /*@__PURE__*/new Vector3();\nconst _box = /*@__PURE__*/new Box3();\nconst _boxMorphTargets = /*@__PURE__*/new Box3();\nconst _vector = /*@__PURE__*/new Vector3();\nclass BufferGeometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isBufferGeometry = true;\n    Object.defineProperty(this, 'id', {\n      value: _id++\n    });\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'BufferGeometry';\n    this.index = null;\n    this.indirect = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.morphTargetsRelative = false;\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.drawRange = {\n      start: 0,\n      count: Infinity\n    };\n    this.userData = {};\n  }\n  getIndex() {\n    return this.index;\n  }\n  setIndex(index) {\n    if (Array.isArray(index)) {\n      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n    return this;\n  }\n  setIndirect(indirect) {\n    this.indirect = indirect;\n    return this;\n  }\n  getIndirect() {\n    return this.indirect;\n  }\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  }\n  deleteAttribute(name) {\n    delete this.attributes[name];\n    return this;\n  }\n  hasAttribute(name) {\n    return this.attributes[name] !== undefined;\n  }\n  addGroup(start, count, materialIndex = 0) {\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex\n    });\n  }\n  clearGroups() {\n    this.groups = [];\n  }\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n  applyMatrix4(matrix) {\n    const position = this.attributes.position;\n    if (position !== undefined) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n    const normal = this.attributes.normal;\n    if (normal !== undefined) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n    const tangent = this.attributes.tangent;\n    if (tangent !== undefined) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  applyQuaternion(q) {\n    _m1.makeRotationFromQuaternion(q);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n\n    _m1.makeRotationX(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n\n    _m1.makeRotationY(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n\n    _m1.makeRotationZ(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  translate(x, y, z) {\n    // translate geometry\n\n    _m1.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  scale(x, y, z) {\n    // scale geometry\n\n    _m1.makeScale(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  setFromPoints(points) {\n    const positionAttribute = this.getAttribute('position');\n    if (positionAttribute === undefined) {\n      const position = [];\n      for (let i = 0, l = points.length; i < l; i++) {\n        const point = points[i];\n        position.push(point.x, point.y, point.z || 0);\n      }\n      this.setAttribute('position', new Float32BufferAttribute(position, 3));\n    } else {\n      for (let i = 0, l = positionAttribute.count; i < l; i++) {\n        const point = points[i];\n        positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);\n      }\n      if (points.length > positionAttribute.count) {\n        console.warn('THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.');\n      }\n      positionAttribute.needsUpdate = true;\n    }\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this);\n      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n      return;\n    }\n    if (position !== undefined) {\n      this.boundingBox.setFromBufferAttribute(position);\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _box.setFromBufferAttribute(morphAttribute);\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(this.boundingBox.min, _box.min);\n            this.boundingBox.expandByPoint(_vector);\n            _vector.addVectors(this.boundingBox.max, _box.max);\n            this.boundingBox.expandByPoint(_vector);\n          } else {\n            this.boundingBox.expandByPoint(_box.min);\n            this.boundingBox.expandByPoint(_box.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this);\n      this.boundingSphere.set(new Vector3(), Infinity);\n      return;\n    }\n    if (position) {\n      // first, find the center of the bounding sphere\n\n      const center = this.boundingSphere.center;\n      _box.setFromBufferAttribute(position);\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(_box.min, _boxMorphTargets.min);\n            _box.expandByPoint(_vector);\n            _vector.addVectors(_box.max, _boxMorphTargets.max);\n            _box.expandByPoint(_vector);\n          } else {\n            _box.expandByPoint(_boxMorphTargets.min);\n            _box.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n      _box.getCenter(center);\n\n      // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n      let maxRadiusSq = 0;\n      for (let i = 0, il = position.count; i < il; i++) {\n        _vector.fromBufferAttribute(position, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n\n      // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          const morphTargetsRelative = this.morphTargetsRelative;\n          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector.fromBufferAttribute(morphAttribute, j);\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n              _vector.add(_offset);\n            }\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n          }\n        }\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  }\n  computeTangents() {\n    const index = this.index;\n    const attributes = this.attributes;\n\n    // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n      return;\n    }\n    const positionAttribute = attributes.position;\n    const normalAttribute = attributes.normal;\n    const uvAttribute = attributes.uv;\n    if (this.hasAttribute('tangent') === false) {\n      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));\n    }\n    const tangentAttribute = this.getAttribute('tangent');\n    const tan1 = [],\n      tan2 = [];\n    for (let i = 0; i < positionAttribute.count; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n    const vA = new Vector3(),\n      vB = new Vector3(),\n      vC = new Vector3(),\n      uvA = new Vector2(),\n      uvB = new Vector2(),\n      uvC = new Vector2(),\n      sdir = new Vector3(),\n      tdir = new Vector3();\n    function handleTriangle(a, b, c) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n      uvA.fromBufferAttribute(uvAttribute, a);\n      uvB.fromBufferAttribute(uvAttribute, b);\n      uvC.fromBufferAttribute(uvAttribute, c);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);\n\n      // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n    let groups = this.groups;\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: index.count\n      }];\n    }\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));\n      }\n    }\n    const tmp = new Vector3(),\n      tmp2 = new Vector3();\n    const n = new Vector3(),\n      n2 = new Vector3();\n    function handleVertex(v) {\n      n.fromBufferAttribute(normalAttribute, v);\n      n2.copy(n);\n      const t = tan1[v];\n\n      // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n\n      // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      const test = tmp2.dot(tan2[v]);\n      const w = test < 0.0 ? -1.0 : 1.0;\n      tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);\n    }\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(index.getX(j + 0));\n        handleVertex(index.getX(j + 1));\n        handleVertex(index.getX(j + 2));\n      }\n    }\n  }\n  computeVertexNormals() {\n    const index = this.index;\n    const positionAttribute = this.getAttribute('position');\n    if (positionAttribute !== undefined) {\n      let normalAttribute = this.getAttribute('normal');\n      if (normalAttribute === undefined) {\n        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n        this.setAttribute('normal', normalAttribute);\n      } else {\n        // reset existing normals to zero\n\n        for (let i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n      const pA = new Vector3(),\n        pB = new Vector3(),\n        pC = new Vector3();\n      const nA = new Vector3(),\n        nB = new Vector3(),\n        nC = new Vector3();\n      const cb = new Vector3(),\n        ab = new Vector3();\n\n      // indexed elements\n\n      if (index) {\n        for (let i = 0, il = index.count; i < il; i += 3) {\n          const vA = index.getX(i + 0);\n          const vB = index.getX(i + 1);\n          const vC = index.getX(i + 2);\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          pB.fromBufferAttribute(positionAttribute, i + 1);\n          pC.fromBufferAttribute(positionAttribute, i + 2);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n      this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  }\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n    for (let i = 0, il = normals.count; i < il; i++) {\n      _vector.fromBufferAttribute(normals, i);\n      _vector.normalize();\n      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n  }\n  toNonIndexed() {\n    function convertBufferAttribute(attribute, indices) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const normalized = attribute.normalized;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n        index2 = 0;\n      for (let i = 0, l = indices.length; i < l; i++) {\n        if (attribute.isInterleavedBufferAttribute) {\n          index = indices[i] * attribute.data.stride + attribute.offset;\n        } else {\n          index = indices[i] * itemSize;\n        }\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new BufferAttribute(array2, itemSize, normalized);\n    }\n\n    //\n\n    if (this.index === null) {\n      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');\n      return this;\n    }\n    const geometry2 = new BufferGeometry();\n    const indices = this.index.array;\n    const attributes = this.attributes;\n\n    // attributes\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      const newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    }\n\n    // morph attributes\n\n    const morphAttributes = this.morphAttributes;\n    for (const name in morphAttributes) {\n      const morphArray = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const attribute = morphAttribute[i];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        morphArray.push(newAttribute);\n      }\n      geometry2.morphAttributes[name] = morphArray;\n    }\n    geometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n    // groups\n\n    const groups = this.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n    return geometry2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.6,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON'\n      }\n    };\n\n    // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n      for (const key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n      return data;\n    }\n\n    // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n    data.data = {\n      attributes: {}\n    };\n    const index = this.index;\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n    const attributes = this.attributes;\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      data.data.attributes[key] = attribute.toJSON(data.data);\n    }\n    const morphAttributes = {};\n    let hasMorphAttributes = false;\n    for (const key in this.morphAttributes) {\n      const attributeArray = this.morphAttributes[key];\n      const array = [];\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n        const attribute = attributeArray[i];\n        array.push(attribute.toJSON(data.data));\n      }\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = true;\n      }\n    }\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n    const groups = this.groups;\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n    const boundingSphere = this.boundingSphere;\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n    return data;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    // reset\n\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n\n    // used for storing cloned, shared data\n\n    const data = {};\n\n    // name\n\n    this.name = source.name;\n\n    // index\n\n    const index = source.index;\n    if (index !== null) {\n      this.setIndex(index.clone(data));\n    }\n\n    // attributes\n\n    const attributes = source.attributes;\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      this.setAttribute(name, attribute.clone(data));\n    }\n\n    // morph attributes\n\n    const morphAttributes = source.morphAttributes;\n    for (const name in morphAttributes) {\n      const array = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n      this.morphAttributes[name] = array;\n    }\n    this.morphTargetsRelative = source.morphTargetsRelative;\n\n    // groups\n\n    const groups = source.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    // bounding box\n\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n\n    // bounding sphere\n\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n\n    // draw range\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count;\n\n    // user data\n\n    this.userData = source.userData;\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n}\nexport { BufferGeometry };","map":{"version":3,"names":["Vector3","Vector2","Box3","EventDispatcher","BufferAttribute","Float32BufferAttribute","Uint16BufferAttribute","Uint32BufferAttribute","Sphere","Object3D","Matrix4","Matrix3","MathUtils","arrayNeedsUint32","_id","_m1","_obj","_offset","_box","_boxMorphTargets","_vector","BufferGeometry","constructor","isBufferGeometry","Object","defineProperty","value","uuid","generateUUID","name","type","index","indirect","attributes","morphAttributes","morphTargetsRelative","groups","boundingBox","boundingSphere","drawRange","start","count","Infinity","userData","getIndex","setIndex","Array","isArray","setIndirect","getIndirect","getAttribute","setAttribute","attribute","deleteAttribute","hasAttribute","undefined","addGroup","materialIndex","push","clearGroups","setDrawRange","applyMatrix4","matrix","position","needsUpdate","normal","normalMatrix","getNormalMatrix","applyNormalMatrix","tangent","transformDirection","computeBoundingBox","computeBoundingSphere","applyQuaternion","q","makeRotationFromQuaternion","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","center","getCenter","negate","setFromPoints","points","positionAttribute","i","l","length","point","setXYZ","console","warn","morphAttributesPosition","isGLBufferAttribute","error","set","setFromBufferAttribute","il","morphAttribute","addVectors","min","expandByPoint","max","makeEmpty","isNaN","maxRadiusSq","fromBufferAttribute","Math","distanceToSquared","j","jl","add","radius","sqrt","computeTangents","uv","normalAttribute","uvAttribute","Float32Array","tangentAttribute","tan1","tan2","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","handleTriangle","a","b","c","sub","r","isFinite","copy","multiplyScalar","addScaledVector","group","getX","tmp","tmp2","n","n2","handleVertex","v","t","dot","normalize","crossVectors","test","w","setXYZW","computeVertexNormals","pA","pB","pC","nA","nB","nC","cb","ab","subVectors","cross","normalizeNormals","normals","toNonIndexed","convertBufferAttribute","indices","array","itemSize","normalized","array2","index2","isInterleavedBufferAttribute","data","stride","offset","geometry2","newAttribute","morphArray","toJSON","metadata","version","generator","keys","parameters","key","prototype","slice","call","hasMorphAttributes","attributeArray","JSON","parse","stringify","toArray","clone","source","dispose","dispatchEvent"],"sources":["C:/Users/21064/Desktop/frontend/node_modules/three/src/core/BufferGeometry.js"],"sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { arrayNeedsUint32 } from '../utils.js';\n\nlet _id = 0;\n\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBufferGeometry = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.indirect = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\t\tthis.morphTargetsRelative = false;\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\tthis.userData = {};\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetIndirect( indirect ) {\n\n\t\tthis.indirect = indirect;\n\n\t\treturn this;\n\n\t}\n\n\tgetIndirect() {\n\n\t\treturn this.indirect;\n\n\t}\n\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute === undefined ) {\n\n\t\t\tconst position = [];\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\tconst point = points[ i ];\n\t\t\t\tpositionAttribute.setXYZ( i, point.x, point.y, point.z || 0 );\n\n\t\t\t}\n\n\t\t\tif ( points.length > positionAttribute.count ) {\n\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.' );\n\n\t\t\t}\n\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst positionAttribute = attributes.position;\n\t\tconst normalAttribute = attributes.normal;\n\t\tconst uvAttribute = attributes.uv;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * positionAttribute.count ), 4 ) );\n\n\t\t}\n\n\t\tconst tangentAttribute = this.getAttribute( 'tangent' );\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tuvA.fromBufferAttribute( uvAttribute, a );\n\t\t\tuvB.fromBufferAttribute( uvAttribute, b );\n\t\t\tuvC.fromBufferAttribute( uvAttribute, c );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: index.count\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindex.getX( j + 0 ),\n\t\t\t\t\tindex.getX( j + 1 ),\n\t\t\t\t\tindex.getX( j + 2 )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromBufferAttribute( normalAttribute, v );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangentAttribute.setXYZW( v, tmp.x, tmp.y, tmp.z, w );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( index.getX( j + 0 ) );\n\t\t\t\thandleVertex( index.getX( j + 1 ) );\n\t\t\t\thandleVertex( index.getX( j + 2 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nexport { BufferGeometry };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}