{"ast":null,"code":"import * as THREE from \"three\";\nimport { mergeGeometries } from \"three/examples/jsm/utils/BufferGeometryUtils.js\";\nimport { randomRangeLinear, disturbedCurveNode, makeVector3, makeVectors } from \"./utilities\";\nimport { LeafGeometry } from \"./leaf_flower_fruit/LeafGeometry\";\nimport { FlowerGeometry } from \"./leaf_flower_fruit/FlowerGeometry\";\nimport { TreeSkeleton } from \"./TreeSkeleton\";\nimport { BranchTubeGeometry } from \"./lib/BranchTubeGeometry\";\nimport { kMeans } from \"./lib/Cluster\";\n/*************************************************************************************\n * CLASS NAME:  TreeBuilder\n * DESCRIPTION: A novel tree editor & generator on the webpage.\n * NOTE:        I'm a piece of shit not knowing to use THREE.TubeGeometry!\n *              (Anyway, at least I tried.üòÇ)\n *\n *************************************************************************************/\nclass TreeBuilder {\n  constructor(treeObj, mergeLeaves = true, scene = null, verticalAxis = \"y-axis\") {\n    this.scene = scene;\n    this.treeObj = treeObj;\n    this.branchGeometries = [];\n    this.cnt = 0; // Âè∂Â≠êËÆ°Êï∞Âô®\n    this.mergeLeaves = mergeLeaves;\n    if (mergeLeaves) {\n      this.leaf_matrices = [];\n      this.flower_matrices = [];\n    }\n    this.X = new THREE.Vector3(1, 0, 0);\n    this.Y = new THREE.Vector3(0, 1, 0);\n    this.Z = new THREE.Vector3(0, 0, 1);\n  }\n  init(treeObj, mergeLeaves = true, verticalAxis = \"y-axis\") {\n    this.treeObj = treeObj;\n    this.mergeLeaves = mergeLeaves;\n    if (mergeLeaves) {\n      this.leaf_matrices = [];\n      this.flower_matrices = [];\n    }\n    if (verticalAxis === \"y-axis\") this.verticalAxis = new THREE.Vector3(0, 1, 0);else if (verticalAxis === \"z-axis\") this.verticalAxis = new THREE.Vector3(0, 0, 1);\n  }\n  setModelPrecision(segment) {\n    this.treeObj.segment = segment;\n  }\n  clearMesh() {\n    this.branchGeometries = [];\n    this.cnt = 0;\n    if (this.mergeLeaves) {\n      this.leaf_matrices = [];\n      this.flower_matrices = [];\n    }\n  }\n\n  // randomMatrices(\n  //   curve,\n  //   points,\n  //   base_position,\n  //   position_noise,\n  //   base_angle,\n  //   angle_noise,\n  //   number\n  // ) {\n  //   const matrices = [];\n  //   let pointsLength = points.length;\n  //   let rot1 = new THREE.Matrix4().makeRotationAxis(\n  //     this.X,\n  //     Math.PI / 2 + randomRangeLinear(-0.3, 0.3)\n  //   );\n  //   for (let i = 1; i <= number; i++) {\n  //     let base = Math.floor(\n  //       pointsLength *\n  //         (base_position + randomRangeLinear(-position_noise, position_noise))\n  //     );\n  //     let position = points[base];\n  //     let tangent = curve.getTangent(base / pointsLength);\n  //     base_angle = -base_angle;\n  //     let tangent_xoz = tangent\n  //       .clone()\n  //       .setY(0)\n  //       .applyAxisAngle(\n  //         this.Y,\n  //         base_angle + randomRangeLinear(-angle_noise, angle_noise)\n  //       );\n  //     let rot_angle = this.Z.angleTo(tangent_xoz);\n  //     if (tangent_xoz.x < 0) rot_angle = -rot_angle;\n  //     let rot2 = new THREE.Matrix4().makeRotationAxis(this.Y, rot_angle);\n  //     let trans = new THREE.Matrix4().makeTranslation(\n  //       position.x,\n  //       position.y,\n  //       position.z\n  //     );\n  //     let rot = new THREE.Matrix4().multiply(rot2).multiply(rot1);\n  //     let matrix = new THREE.Matrix4().multiply(trans).multiply(rot);\n  //     matrices.push(matrix);\n  //   }\n  //   return matrices;\n  // }\n\n  randomMatrices(curve, points, base_position, position_noise, base_angle, angle_noise, number) {\n    const matrices = [];\n    let pointsLength = points.length;\n    let dir;\n    for (let i = 1; i <= number; i++) {\n      let base = Math.floor(pointsLength * (base_position + randomRangeLinear(-position_noise, position_noise)));\n      let position = points[base];\n      let tangent = curve.getTangent(base / pointsLength);\n      let orthogonal = new THREE.Vector3(0, 1, -tangent.y / tangent.z).normalize();\n      if (i === 1) {\n        dir = new THREE.Vector3().copy(tangent).applyAxisAngle(orthogonal, base_angle + randomRangeLinear(-angle_noise, angle_noise)).applyAxisAngle(tangent, Math.random() * Math.PI / 2).normalize();\n      } else {\n        dir.applyAxisAngle(tangent, 2 * Math.PI / number).normalize();\n      }\n      let rot_angle = this.verticalAxis.angleTo(dir);\n      let rot_axis = new THREE.Vector3().crossVectors(this.verticalAxis, dir).normalize();\n      let trans = new THREE.Matrix4().makeTranslation(position.x, position.y, position.z);\n      let rot1 = new THREE.Matrix4().makeRotationAxis(this.verticalAxis, Math.random() * 2 * Math.PI),\n        // (0,2pi)\n        rot2 = new THREE.Matrix4().makeRotationAxis(rot_axis, rot_angle);\n      let rot = new THREE.Matrix4().multiply(rot2).multiply(rot1);\n      let matrix = new THREE.Matrix4().multiply(trans).multiply(rot);\n      matrices.push(matrix);\n    }\n    return matrices;\n  }\n  buildSkeletonRec(start, end, fatherSkeleton, depth = 0) {\n    if (depth > this.treeObj.depth) return;\n\n    // let disturb = depth === this.treeObj.depth ? 0 : this.treeObj.disturb;\n    let disturb = depth === 0 ? 0 : this.treeObj.disturb;\n    let gravity = depth === 0 ? 0 : this.treeObj.gravity;\n    const nodes = disturbedCurveNode(makeVector3(start), makeVector3(end), disturb, gravity);\n    const curSkeleton = new TreeSkeleton(nodes);\n    fatherSkeleton.add(curSkeleton);\n    const curve = new THREE.CatmullRomCurve3(nodes);\n    const points = curve.getPoints(50);\n    const pointsLength = points.length; // 51\n    const cur_node = this.treeObj.branches[depth],\n      next_node = this.treeObj.branches[depth + 1];\n    if (!next_node) return;\n    const sub_branches = cur_node.sub_branches;\n    let dir, tangent;\n    for (let i = 0; i < sub_branches.length; i++) {\n      for (let j = 1; j <= sub_branches[i][6]; j++) {\n        let base = Math.floor(pointsLength * (sub_branches[i][0] + randomRangeLinear(-sub_branches[i][1], sub_branches[i][1])));\n        let s = points[base];\n        if (j === 1) {\n          tangent = curve.getTangent(base / pointsLength);\n          let orthogonal = new THREE.Vector3(0, -tangent.z / tangent.y, 1).normalize();\n          dir = new THREE.Vector3().copy(tangent).applyAxisAngle(orthogonal, sub_branches[i][2] + randomRangeLinear(-sub_branches[i][3], sub_branches[i][3])).applyAxisAngle(tangent, Math.random() * Math.PI / 2).normalize();\n        } else {\n          dir.applyAxisAngle(tangent, 2 * Math.PI / sub_branches[i][6]).normalize();\n        }\n        let e = new THREE.Vector3().addVectors(s, dir.multiplyScalar(sub_branches[i][4] + randomRangeLinear(-sub_branches[i][5], sub_branches[i][5])));\n        this.buildSkeletonRec(s, e, curSkeleton, depth + 1);\n      }\n    }\n  }\n  buildTreeRec(skeleton, radius, depth = 0) {\n    if (depth > this.treeObj.depth) return;\n\n    // radius = radius <= 0.1 ? 0.1 : radius;\n    const vectors = makeVectors(skeleton.positions);\n    const curve = new THREE.CatmullRomCurve3(vectors);\n    const curveLength = vectors[0].distanceTo(vectors.at(-1));\n    const points = curve.getPoints(50);\n    const {\n      tubular_segments,\n      radial_segments,\n      sample_offset\n    } = this.treeObj; // Ê†ëÂπ≤ÂàÜÊàêÁöÑÊÆµÊï∞\n\n    if (skeleton.children.length === 0) {\n      // Âè∂Â≠êËäÇÁÇπ\n      const leaves = this.treeObj.branches.at(-1).leaves;\n      const flowers = this.treeObj.branches.at(-1).flowers;\n      let matrices1, matrices2;\n      for (let i = 0; i < leaves.length; i++) {\n        // leaf\n        matrices1 = this.randomMatrices(curve, points, leaves[i][0], leaves[i][1], leaves[i][2], leaves[i][3], leaves[i][4]);\n        // flower\n        if (flowers) {\n          matrices2 = this.randomMatrices(curve, points, flowers[i][0], flowers[i][1], flowers[i][2], flowers[i][3], flowers[i][4]);\n        }\n        if (this.mergeLeaves) {\n          this.leaf_matrices.push(...matrices1);\n          if (this.treeObj.flower && flowers) this.flower_matrices.push(...matrices2);\n          if (this.treeObj.flower && !flowers) this.flower_matrices.push(...matrices1);\n        }\n      }\n    }\n    const branchGeometry = new BranchTubeGeometry(curve, tubular_segments, radius, radial_segments, false, (1 - this.treeObj.shrink.single) * radius / tubular_segments, curveLength * sample_offset);\n    this.branchGeometries.push(branchGeometry);\n    skeleton.children.forEach(child => {\n      this.buildTreeRec(child, radius * this.treeObj.shrink.multi, depth + 1);\n    });\n  }\n  buildKmeansSkeletonRec(data, fatherSkeleton, baseZ = 0, startArray = [], depth = 0) {\n    let totalDepth = this.treeObj.depth;\n    if (depth > totalDepth) return;\n    const cur_node = this.treeObj.branches[depth];\n    let total_branch_num = startArray.length;\n    let {\n      centroids,\n      clusters\n    } = kMeans(data, depth > 0 ? total_branch_num : 1, this.scene);\n    // console.log(total_branch_num, centroids.length / 3);\n    let l = centroids.length;\n    let startVector, centroidVector, endVector;\n    let disturb = depth === 0 ? 0 : this.treeObj.disturb;\n    let gravity = depth === 0 ? 0 : this.treeObj.gravity;\n    for (let i = 0; i < l; i += 3) {\n      let nextStartArray = [];\n      centroidVector = new THREE.Vector3().fromArray(centroids, i);\n      startVector = total_branch_num > 0 ? startArray[i / 3] : new THREE.Vector3(centroidVector.x, centroidVector.y, baseZ);\n      endVector = new THREE.Vector3().addVectors(startVector, centroidVector).divideScalar(2);\n      // if (depth === totalDepth)\n      //   endVector.setX(centroidVector.x).setY(centroidVector.y);\n\n      // Â≠òÂÇ®È™®Êû∂\n      let treeNodes = disturbedCurveNode(startVector, endVector, disturb, gravity);\n      let curSkeleton = new TreeSkeleton(treeNodes);\n      fatherSkeleton.add(curSkeleton);\n\n      // ÁîüÊàê‰∏ãÊ¨°ÈÄíÂΩíÁöÑÂºÄÂßãËäÇÁÇπ\n      if (depth < totalDepth) {\n        let curve = new THREE.CatmullRomCurve3(treeNodes);\n        let points = curve.getPoints(50);\n        let pointsLength = points.length;\n        cur_node.sub_branches.forEach(sub_branch => {\n          for (let _ = 0; _ < sub_branch.at(-1); _++) {\n            let base = Math.floor(pointsLength * (sub_branch[0] + randomRangeLinear(-sub_branch[1], sub_branch[1])));\n            nextStartArray.push(points[base]);\n          }\n        });\n      }\n      this.buildKmeansSkeletonRec(clusters.get(i / 3), curSkeleton, baseZ, nextStartArray, depth + 1);\n    }\n  }\n\n  // public\n  buildSkeleton() {\n    const {\n      treeObj\n    } = this;\n    const trunk = treeObj.branches[0];\n    const treeSkeleton = new TreeSkeleton();\n    this.buildSkeletonRec(trunk.start, trunk.end, treeSkeleton);\n    treeSkeleton.setTreeObj(treeObj);\n    return treeSkeleton;\n  }\n\n  // public\n  buildKmeansSkeleton(data, baseZ) {\n    const {\n      treeObj\n    } = this;\n    const treeSkeleton = new TreeSkeleton();\n    this.buildKmeansSkeletonRec(data, treeSkeleton, baseZ);\n    treeSkeleton.setTreeObj(treeObj);\n    return treeSkeleton;\n  }\n\n  // public\n  buildTree(skeleton) {\n    if (skeleton.children.length === 0) return;\n    const {\n      treeObj,\n      branchGeometries,\n      mergeLeaves,\n      leaf_matrices,\n      flower_matrices,\n      verticalAxis\n    } = this;\n    const loader = new THREE.TextureLoader();\n    const g = treeObj.leaf.geometry;\n    let flowerMaterial, leafMaterial, flowerTexture, leafTexture;\n    const tree = new THREE.Group();\n    if (treeObj.flower) {\n      flowerTexture = loader.load(treeObj.path + \"flower_base.png\");\n      flowerTexture.colorSpace = THREE.SRGBColorSpace;\n      flowerMaterial = new THREE.MeshPhongMaterial({\n        map: flowerTexture,\n        side: THREE.DoubleSide,\n        alphaTest: treeObj.leaf.alpha_test\n      });\n    }\n    leafTexture = loader.load(treeObj.path + \"leaf_base.png\");\n    leafTexture.colorSpace = THREE.SRGBColorSpace;\n    leafMaterial = new THREE.MeshPhongMaterial({\n      map: leafTexture,\n      // map: loader.load(treeObj.path + \"leaf_base_standard.png\"),\n      // normalMap: loader.load(treeObj.path + \"leaf_normal_standard.png\"),\n      side: THREE.DoubleSide,\n      alphaTest: treeObj.leaf.alpha_test\n    });\n\n    // 1. ÂÆû‰æãÂåñÊñπÂºèÂÅöÊ†ëÂè∂ÔºåÈÄíÂΩíÂáΩÊï∞ÂâçÂàõÂª∫mesh\n    // if (!mergeLeaves) {\n    //   this.leaf = new THREE.InstancedMesh(\n    //     new Leaf(\n    //       g.style,\n    //       g.width,\n    //       g.height,\n    //       treeObj.leaves.scale,\n    //       g.foldDegree,\n    //       verticalAxis\n    //     ).generate(),\n    //     leafMaterial,\n    //     treeObj.leaves.total\n    //   );\n    // }\n\n    // 2. ÊâßË°åÈÄíÂΩí\n    const trunk = treeObj.branches[0];\n    this.buildTreeRec(skeleton.children[0], trunk.radius);\n\n    // 3. ÂêàÂπ∂ÊñπÂºèÂÅöÊ†ëÂè∂ÔºåÈÄíÂΩíÂáΩÊï∞ÂêéÂàõÂª∫mesh\n    if (mergeLeaves) {\n      const leafGeometries = [];\n      leaf_matrices.forEach(matrix => {\n        leafGeometries.push(new LeafGeometry(g.style, g.width, g.height, g.width_foldDegree, g.height_foldDegree, verticalAxis).generate().scale(treeObj.leaf.scale, treeObj.leaf.scale, treeObj.leaf.scale).applyMatrix4(matrix));\n      });\n      const mergedLeavesGeometry = mergeGeometries(leafGeometries, false);\n      this.leaf = new THREE.Mesh(mergedLeavesGeometry, leafMaterial);\n      tree.add(this.leaf);\n      if (treeObj.flower) {\n        const flowerGeometries = [];\n        flower_matrices.forEach(matrix => {\n          flowerGeometries.push(new FlowerGeometry().generate().scale(treeObj.flower.scale, treeObj.flower.scale, treeObj.flower.scale).translate(0, 0.12, 0).applyMatrix4(matrix));\n        });\n        const mergedFlowersGeometry = mergeGeometries(flowerGeometries, false);\n        this.flower = new THREE.Mesh(mergedFlowersGeometry, flowerMaterial);\n        tree.add(this.flower);\n      }\n    }\n\n    // 4. ÊûùÂπ≤\n    const twigGeometry = mergeGeometries(branchGeometries, false);\n    // const treeTexture = loader.load(treeObj.path + \"tree_base_standard.png\");\n    const twigTexture = loader.load(treeObj.path + \"tree_base.png\");\n    twigTexture.colorSpace = THREE.SRGBColorSpace;\n    // const treeNormalTexture = loader.load(\n    //   treeObj.path + \"tree_normal_standard.png\"\n    // );\n    twigTexture.wrapT = /*treeNormalTexture.wrapS =*/THREE.RepeatWrapping;\n    twigTexture.repeat.set(1, 5);\n    // treeNormalTexture.repeat.set(2, 1);\n    const twigMaterial = new THREE.MeshPhongMaterial({\n      map: twigTexture\n      // wireframe: true,\n      // normalMap: treeNormalTexture,\n    });\n    const twig = new THREE.Mesh(twigGeometry, twigMaterial);\n    tree.add(twig);\n    return tree;\n  }\n}\nexport { TreeBuilder };","map":{"version":3,"names":["THREE","mergeGeometries","randomRangeLinear","disturbedCurveNode","makeVector3","makeVectors","LeafGeometry","FlowerGeometry","TreeSkeleton","BranchTubeGeometry","kMeans","TreeBuilder","constructor","treeObj","mergeLeaves","scene","verticalAxis","branchGeometries","cnt","leaf_matrices","flower_matrices","X","Vector3","Y","Z","init","setModelPrecision","segment","clearMesh","randomMatrices","curve","points","base_position","position_noise","base_angle","angle_noise","number","matrices","pointsLength","length","dir","i","base","Math","floor","position","tangent","getTangent","orthogonal","y","z","normalize","copy","applyAxisAngle","random","PI","rot_angle","angleTo","rot_axis","crossVectors","trans","Matrix4","makeTranslation","x","rot1","makeRotationAxis","rot2","rot","multiply","matrix","push","buildSkeletonRec","start","end","fatherSkeleton","depth","disturb","gravity","nodes","curSkeleton","add","CatmullRomCurve3","getPoints","cur_node","branches","next_node","sub_branches","j","s","e","addVectors","multiplyScalar","buildTreeRec","skeleton","radius","vectors","positions","curveLength","distanceTo","at","tubular_segments","radial_segments","sample_offset","children","leaves","flowers","matrices1","matrices2","flower","branchGeometry","shrink","single","forEach","child","multi","buildKmeansSkeletonRec","data","baseZ","startArray","totalDepth","total_branch_num","centroids","clusters","l","startVector","centroidVector","endVector","nextStartArray","fromArray","divideScalar","treeNodes","sub_branch","_","get","buildSkeleton","trunk","treeSkeleton","setTreeObj","buildKmeansSkeleton","buildTree","loader","TextureLoader","g","leaf","geometry","flowerMaterial","leafMaterial","flowerTexture","leafTexture","tree","Group","load","path","colorSpace","SRGBColorSpace","MeshPhongMaterial","map","side","DoubleSide","alphaTest","alpha_test","leafGeometries","style","width","height","width_foldDegree","height_foldDegree","generate","scale","applyMatrix4","mergedLeavesGeometry","Mesh","flowerGeometries","translate","mergedFlowersGeometry","twigGeometry","twigTexture","wrapT","RepeatWrapping","repeat","set","twigMaterial","twig"],"sources":["C:/Users/21064/Desktop/frontend/src/TreeBuilder.js"],"sourcesContent":["import * as THREE from \"three\";\nimport { mergeGeometries } from \"three/examples/jsm/utils/BufferGeometryUtils.js\";\nimport {\n  randomRangeLinear,\n  disturbedCurveNode,\n  makeVector3,\n  makeVectors,\n} from \"./utilities\";\nimport { LeafGeometry } from \"./leaf_flower_fruit/LeafGeometry\";\nimport { FlowerGeometry } from \"./leaf_flower_fruit/FlowerGeometry\";\nimport { TreeSkeleton } from \"./TreeSkeleton\";\nimport { BranchTubeGeometry } from \"./lib/BranchTubeGeometry\";\nimport { kMeans } from \"./lib/Cluster\";\n/*************************************************************************************\n * CLASS NAME:  TreeBuilder\n * DESCRIPTION: A novel tree editor & generator on the webpage.\n * NOTE:        I'm a piece of shit not knowing to use THREE.TubeGeometry!\n *              (Anyway, at least I tried.üòÇ)\n *\n *************************************************************************************/\nclass TreeBuilder {\n  constructor(\n    treeObj,\n    mergeLeaves = true,\n    scene = null,\n    verticalAxis = \"y-axis\",\n  ) {\n    this.scene = scene;\n    this.treeObj = treeObj;\n    this.branchGeometries = [];\n    this.cnt = 0; // Âè∂Â≠êËÆ°Êï∞Âô®\n    this.mergeLeaves = mergeLeaves;\n    if (mergeLeaves) {\n      this.leaf_matrices = [];\n      this.flower_matrices = [];\n    }\n    this.X = new THREE.Vector3(1, 0, 0);\n    this.Y = new THREE.Vector3(0, 1, 0);\n    this.Z = new THREE.Vector3(0, 0, 1);\n  }\n\n  init(treeObj, mergeLeaves = true, verticalAxis = \"y-axis\") {\n    this.treeObj = treeObj;\n    this.mergeLeaves = mergeLeaves;\n    if (mergeLeaves) {\n      this.leaf_matrices = [];\n      this.flower_matrices = [];\n    }\n    if (verticalAxis === \"y-axis\")\n      this.verticalAxis = new THREE.Vector3(0, 1, 0);\n    else if (verticalAxis === \"z-axis\")\n      this.verticalAxis = new THREE.Vector3(0, 0, 1);\n  }\n\n  setModelPrecision(segment) {\n    this.treeObj.segment = segment;\n  }\n\n  clearMesh() {\n    this.branchGeometries = [];\n    this.cnt = 0;\n    if (this.mergeLeaves) {\n      this.leaf_matrices = [];\n      this.flower_matrices = [];\n    }\n  }\n\n  // randomMatrices(\n  //   curve,\n  //   points,\n  //   base_position,\n  //   position_noise,\n  //   base_angle,\n  //   angle_noise,\n  //   number\n  // ) {\n  //   const matrices = [];\n  //   let pointsLength = points.length;\n  //   let rot1 = new THREE.Matrix4().makeRotationAxis(\n  //     this.X,\n  //     Math.PI / 2 + randomRangeLinear(-0.3, 0.3)\n  //   );\n  //   for (let i = 1; i <= number; i++) {\n  //     let base = Math.floor(\n  //       pointsLength *\n  //         (base_position + randomRangeLinear(-position_noise, position_noise))\n  //     );\n  //     let position = points[base];\n  //     let tangent = curve.getTangent(base / pointsLength);\n  //     base_angle = -base_angle;\n  //     let tangent_xoz = tangent\n  //       .clone()\n  //       .setY(0)\n  //       .applyAxisAngle(\n  //         this.Y,\n  //         base_angle + randomRangeLinear(-angle_noise, angle_noise)\n  //       );\n  //     let rot_angle = this.Z.angleTo(tangent_xoz);\n  //     if (tangent_xoz.x < 0) rot_angle = -rot_angle;\n  //     let rot2 = new THREE.Matrix4().makeRotationAxis(this.Y, rot_angle);\n  //     let trans = new THREE.Matrix4().makeTranslation(\n  //       position.x,\n  //       position.y,\n  //       position.z\n  //     );\n  //     let rot = new THREE.Matrix4().multiply(rot2).multiply(rot1);\n  //     let matrix = new THREE.Matrix4().multiply(trans).multiply(rot);\n  //     matrices.push(matrix);\n  //   }\n  //   return matrices;\n  // }\n\n  randomMatrices(\n    curve,\n    points,\n    base_position,\n    position_noise,\n    base_angle,\n    angle_noise,\n    number,\n  ) {\n    const matrices = [];\n    let pointsLength = points.length;\n    let dir;\n    for (let i = 1; i <= number; i++) {\n      let base = Math.floor(\n        pointsLength *\n          (base_position + randomRangeLinear(-position_noise, position_noise)),\n      );\n      let position = points[base];\n      let tangent = curve.getTangent(base / pointsLength);\n      let orthogonal = new THREE.Vector3(\n        0,\n        1,\n        -tangent.y / tangent.z,\n      ).normalize();\n      if (i === 1) {\n        dir = new THREE.Vector3()\n          .copy(tangent)\n          .applyAxisAngle(\n            orthogonal,\n            base_angle + randomRangeLinear(-angle_noise, angle_noise),\n          )\n          .applyAxisAngle(tangent, (Math.random() * Math.PI) / 2)\n          .normalize();\n      } else {\n        dir.applyAxisAngle(tangent, (2 * Math.PI) / number).normalize();\n      }\n      let rot_angle = this.verticalAxis.angleTo(dir);\n      let rot_axis = new THREE.Vector3()\n        .crossVectors(this.verticalAxis, dir)\n        .normalize();\n\n      let trans = new THREE.Matrix4().makeTranslation(\n        position.x,\n        position.y,\n        position.z,\n      );\n      let rot1 = new THREE.Matrix4().makeRotationAxis(\n          this.verticalAxis,\n          Math.random() * 2 * Math.PI,\n        ), // (0,2pi)\n        rot2 = new THREE.Matrix4().makeRotationAxis(rot_axis, rot_angle);\n      let rot = new THREE.Matrix4().multiply(rot2).multiply(rot1);\n      let matrix = new THREE.Matrix4().multiply(trans).multiply(rot);\n      matrices.push(matrix);\n    }\n    return matrices;\n  }\n\n  buildSkeletonRec(start, end, fatherSkeleton, depth = 0) {\n    if (depth > this.treeObj.depth) return;\n\n    // let disturb = depth === this.treeObj.depth ? 0 : this.treeObj.disturb;\n    let disturb = depth === 0 ? 0 : this.treeObj.disturb;\n    let gravity = depth === 0 ? 0 : this.treeObj.gravity;\n    const nodes = disturbedCurveNode(\n      makeVector3(start),\n      makeVector3(end),\n      disturb,\n      gravity,\n    );\n    const curSkeleton = new TreeSkeleton(nodes);\n    fatherSkeleton.add(curSkeleton);\n\n    const curve = new THREE.CatmullRomCurve3(nodes);\n    const points = curve.getPoints(50);\n    const pointsLength = points.length; // 51\n    const cur_node = this.treeObj.branches[depth],\n      next_node = this.treeObj.branches[depth + 1];\n    if (!next_node) return;\n\n    const sub_branches = cur_node.sub_branches;\n    let dir, tangent;\n    for (let i = 0; i < sub_branches.length; i++) {\n      for (let j = 1; j <= sub_branches[i][6]; j++) {\n        let base = Math.floor(\n          pointsLength *\n            (sub_branches[i][0] +\n              randomRangeLinear(-sub_branches[i][1], sub_branches[i][1])),\n        );\n        let s = points[base];\n        if (j === 1) {\n          tangent = curve.getTangent(base / pointsLength);\n          let orthogonal = new THREE.Vector3(\n            0,\n            -tangent.z / tangent.y,\n            1,\n          ).normalize();\n          dir = new THREE.Vector3()\n            .copy(tangent)\n            .applyAxisAngle(\n              orthogonal,\n              sub_branches[i][2] +\n                randomRangeLinear(-sub_branches[i][3], sub_branches[i][3]),\n            )\n            .applyAxisAngle(tangent, (Math.random() * Math.PI) / 2)\n            .normalize();\n        } else {\n          dir\n            .applyAxisAngle(tangent, (2 * Math.PI) / sub_branches[i][6])\n            .normalize();\n        }\n        let e = new THREE.Vector3().addVectors(\n          s,\n          dir.multiplyScalar(\n            sub_branches[i][4] +\n              randomRangeLinear(-sub_branches[i][5], sub_branches[i][5]),\n          ),\n        );\n        this.buildSkeletonRec(s, e, curSkeleton, depth + 1);\n      }\n    }\n  }\n\n  buildTreeRec(skeleton, radius, depth = 0) {\n    if (depth > this.treeObj.depth) return;\n\n    // radius = radius <= 0.1 ? 0.1 : radius;\n    const vectors = makeVectors(skeleton.positions);\n    const curve = new THREE.CatmullRomCurve3(vectors);\n    const curveLength = vectors[0].distanceTo(vectors.at(-1));\n    const points = curve.getPoints(50);\n    const { tubular_segments, radial_segments, sample_offset } = this.treeObj; // Ê†ëÂπ≤ÂàÜÊàêÁöÑÊÆµÊï∞\n\n    if (skeleton.children.length === 0) {\n      // Âè∂Â≠êËäÇÁÇπ\n      const leaves = this.treeObj.branches.at(-1).leaves;\n      const flowers = this.treeObj.branches.at(-1).flowers;\n      let matrices1, matrices2;\n      for (let i = 0; i < leaves.length; i++) {\n        // leaf\n        matrices1 = this.randomMatrices(\n          curve,\n          points,\n          leaves[i][0],\n          leaves[i][1],\n          leaves[i][2],\n          leaves[i][3],\n          leaves[i][4],\n        );\n        // flower\n        if (flowers) {\n          matrices2 = this.randomMatrices(\n            curve,\n            points,\n            flowers[i][0],\n            flowers[i][1],\n            flowers[i][2],\n            flowers[i][3],\n            flowers[i][4],\n          );\n        }\n        if (this.mergeLeaves) {\n          this.leaf_matrices.push(...matrices1);\n          if (this.treeObj.flower && flowers)\n            this.flower_matrices.push(...matrices2);\n          if (this.treeObj.flower && !flowers)\n            this.flower_matrices.push(...matrices1);\n        }\n      }\n    }\n\n    const branchGeometry = new BranchTubeGeometry(\n      curve,\n      tubular_segments,\n      radius,\n      radial_segments,\n      false,\n      ((1 - this.treeObj.shrink.single) * radius) / tubular_segments,\n      curveLength * sample_offset,\n    );\n    this.branchGeometries.push(branchGeometry);\n    skeleton.children.forEach((child) => {\n      this.buildTreeRec(child, radius * this.treeObj.shrink.multi, depth + 1);\n    });\n  }\n\n  buildKmeansSkeletonRec(\n    data,\n    fatherSkeleton,\n    baseZ = 0,\n    startArray = [],\n    depth = 0,\n  ) {\n    let totalDepth = this.treeObj.depth;\n    if (depth > totalDepth) return;\n\n    const cur_node = this.treeObj.branches[depth];\n    let total_branch_num = startArray.length;\n    let { centroids, clusters } = kMeans(\n      data,\n      depth > 0 ? total_branch_num : 1,\n      this.scene,\n    );\n    // console.log(total_branch_num, centroids.length / 3);\n    let l = centroids.length;\n    let startVector, centroidVector, endVector;\n    let disturb = depth === 0 ? 0 : this.treeObj.disturb;\n    let gravity = depth === 0 ? 0 : this.treeObj.gravity;\n\n    for (let i = 0; i < l; i += 3) {\n      let nextStartArray = [];\n      centroidVector = new THREE.Vector3().fromArray(centroids, i);\n      startVector =\n        total_branch_num > 0\n          ? startArray[i / 3]\n          : new THREE.Vector3(centroidVector.x, centroidVector.y, baseZ);\n      endVector = new THREE.Vector3()\n        .addVectors(startVector, centroidVector)\n        .divideScalar(2);\n      // if (depth === totalDepth)\n      //   endVector.setX(centroidVector.x).setY(centroidVector.y);\n\n      // Â≠òÂÇ®È™®Êû∂\n      let treeNodes = disturbedCurveNode(\n        startVector,\n        endVector,\n        disturb,\n        gravity,\n      );\n      let curSkeleton = new TreeSkeleton(treeNodes);\n      fatherSkeleton.add(curSkeleton);\n\n      // ÁîüÊàê‰∏ãÊ¨°ÈÄíÂΩíÁöÑÂºÄÂßãËäÇÁÇπ\n      if (depth < totalDepth) {\n        let curve = new THREE.CatmullRomCurve3(treeNodes);\n        let points = curve.getPoints(50);\n        let pointsLength = points.length;\n        cur_node.sub_branches.forEach((sub_branch) => {\n          for (let _ = 0; _ < sub_branch.at(-1); _++) {\n            let base = Math.floor(\n              pointsLength *\n                (sub_branch[0] +\n                  randomRangeLinear(-sub_branch[1], sub_branch[1])),\n            );\n            nextStartArray.push(points[base]);\n          }\n        });\n      }\n\n      this.buildKmeansSkeletonRec(\n        clusters.get(i / 3),\n        curSkeleton,\n        baseZ,\n        nextStartArray,\n        depth + 1,\n      );\n    }\n  }\n\n  // public\n  buildSkeleton() {\n    const { treeObj } = this;\n    const trunk = treeObj.branches[0];\n    const treeSkeleton = new TreeSkeleton();\n    this.buildSkeletonRec(trunk.start, trunk.end, treeSkeleton);\n    treeSkeleton.setTreeObj(treeObj);\n    return treeSkeleton;\n  }\n\n  // public\n  buildKmeansSkeleton(data, baseZ) {\n    const { treeObj } = this;\n    const treeSkeleton = new TreeSkeleton();\n    this.buildKmeansSkeletonRec(data, treeSkeleton, baseZ);\n    treeSkeleton.setTreeObj(treeObj);\n    return treeSkeleton;\n  }\n\n  // public\n  buildTree(skeleton) {\n    if (skeleton.children.length === 0) return;\n    const {\n      treeObj,\n      branchGeometries,\n      mergeLeaves,\n      leaf_matrices,\n      flower_matrices,\n      verticalAxis,\n    } = this;\n\n    const loader = new THREE.TextureLoader();\n    const g = treeObj.leaf.geometry;\n    let flowerMaterial, leafMaterial, flowerTexture, leafTexture;\n    const tree = new THREE.Group();\n\n    if (treeObj.flower) {\n      flowerTexture = loader.load(treeObj.path + \"flower_base.png\");\n      flowerTexture.colorSpace = THREE.SRGBColorSpace;\n      flowerMaterial = new THREE.MeshPhongMaterial({\n        map: flowerTexture,\n        side: THREE.DoubleSide,\n        alphaTest: treeObj.leaf.alpha_test,\n      });\n    }\n    leafTexture = loader.load(treeObj.path + \"leaf_base.png\");\n    leafTexture.colorSpace = THREE.SRGBColorSpace;\n    leafMaterial = new THREE.MeshPhongMaterial({\n      map: leafTexture,\n      // map: loader.load(treeObj.path + \"leaf_base_standard.png\"),\n      // normalMap: loader.load(treeObj.path + \"leaf_normal_standard.png\"),\n      side: THREE.DoubleSide,\n      alphaTest: treeObj.leaf.alpha_test,\n    });\n\n    // 1. ÂÆû‰æãÂåñÊñπÂºèÂÅöÊ†ëÂè∂ÔºåÈÄíÂΩíÂáΩÊï∞ÂâçÂàõÂª∫mesh\n    // if (!mergeLeaves) {\n    //   this.leaf = new THREE.InstancedMesh(\n    //     new Leaf(\n    //       g.style,\n    //       g.width,\n    //       g.height,\n    //       treeObj.leaves.scale,\n    //       g.foldDegree,\n    //       verticalAxis\n    //     ).generate(),\n    //     leafMaterial,\n    //     treeObj.leaves.total\n    //   );\n    // }\n\n    // 2. ÊâßË°åÈÄíÂΩí\n    const trunk = treeObj.branches[0];\n    this.buildTreeRec(skeleton.children[0], trunk.radius);\n\n    // 3. ÂêàÂπ∂ÊñπÂºèÂÅöÊ†ëÂè∂ÔºåÈÄíÂΩíÂáΩÊï∞ÂêéÂàõÂª∫mesh\n    if (mergeLeaves) {\n      const leafGeometries = [];\n      leaf_matrices.forEach((matrix) => {\n        leafGeometries.push(\n          new LeafGeometry(\n            g.style,\n            g.width,\n            g.height,\n            g.width_foldDegree,\n            g.height_foldDegree,\n            verticalAxis,\n          )\n            .generate()\n            .scale(treeObj.leaf.scale, treeObj.leaf.scale, treeObj.leaf.scale)\n            .applyMatrix4(matrix),\n        );\n      });\n      const mergedLeavesGeometry = mergeGeometries(leafGeometries, false);\n      this.leaf = new THREE.Mesh(mergedLeavesGeometry, leafMaterial);\n      tree.add(this.leaf);\n\n      if (treeObj.flower) {\n        const flowerGeometries = [];\n        flower_matrices.forEach((matrix) => {\n          flowerGeometries.push(\n            new FlowerGeometry()\n              .generate()\n              .scale(\n                treeObj.flower.scale,\n                treeObj.flower.scale,\n                treeObj.flower.scale,\n              )\n              .translate(0, 0.12, 0)\n              .applyMatrix4(matrix),\n          );\n        });\n        const mergedFlowersGeometry = mergeGeometries(flowerGeometries, false);\n        this.flower = new THREE.Mesh(mergedFlowersGeometry, flowerMaterial);\n\n        tree.add(this.flower);\n      }\n    }\n\n    // 4. ÊûùÂπ≤\n    const twigGeometry = mergeGeometries(branchGeometries, false);\n    // const treeTexture = loader.load(treeObj.path + \"tree_base_standard.png\");\n    const twigTexture = loader.load(treeObj.path + \"tree_base.png\");\n    twigTexture.colorSpace = THREE.SRGBColorSpace;\n    // const treeNormalTexture = loader.load(\n    //   treeObj.path + \"tree_normal_standard.png\"\n    // );\n    twigTexture.wrapT = /*treeNormalTexture.wrapS =*/ THREE.RepeatWrapping;\n    twigTexture.repeat.set(1, 5);\n    // treeNormalTexture.repeat.set(2, 1);\n    const twigMaterial = new THREE.MeshPhongMaterial({\n      map: twigTexture,\n      // wireframe: true,\n      // normalMap: treeNormalTexture,\n    });\n    const twig = new THREE.Mesh(twigGeometry, twigMaterial);\n    tree.add(twig);\n    return tree;\n  }\n}\n\nexport { TreeBuilder };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}