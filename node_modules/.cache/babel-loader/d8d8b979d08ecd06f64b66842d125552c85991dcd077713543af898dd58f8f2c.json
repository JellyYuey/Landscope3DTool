{"ast":null,"code":"import * as THREE from \"three\";\nimport { Octree } from \"./Octree\";\nimport { toSeePoint } from \"../utilities\";\n\n/* 工具函数 */\n\n// 从数组中获取一个三维坐标\nconst extract = (arr, index) => {\n  return [arr[index], arr[index + 1], arr[index + 2]];\n};\n\n// 计算两点间的欧氏距离\nconst euclideanDistance = (n1, n2) => {\n  return Math.sqrt((n1[0] - n2[0]) ** 2 + (n1[1] - n2[1]) ** 2 + (n1[2] - n2[2]) ** 2);\n};\nconst luDistance = (n1, n2) => {\n  // centroid always be n1\n  let sum = (n1[0] - n2[0]) ** 2 + (n1[1] - n2[1]) ** 2;\n  return sum / n1[2] ** 3;\n};\n\n// 计算三维点集的平均点坐标\nconst mean = data => {\n  let x = 0,\n    y = 0,\n    z = 0;\n  let l = data.length;\n  for (let i = 0; i < l; i += 3) {\n    x += data[i];\n    y += data[i + 1];\n    z += data[i + 2];\n  }\n  x /= l / 3;\n  y /= l / 3;\n  z /= l / 3;\n  return [x, y, z];\n};\n\n// 计算点云的包围盒，点云以数组形式存储\nconst getBoundingBox = data => {\n  let l = data.length;\n  let minx = +Infinity,\n    miny = +Infinity,\n    minz = +Infinity,\n    maxx = -Infinity,\n    maxy = -Infinity,\n    maxz = -Infinity;\n  for (let i = 0; i < l; i += 3) {\n    minx = Math.min(data[i], minx);\n    miny = Math.min(data[i + 1], miny);\n    minz = Math.min(data[i + 2], minz);\n    maxx = Math.max(data[i], maxx);\n    maxy = Math.max(data[i + 1], maxy);\n    maxz = Math.max(data[i + 2], maxz);\n  }\n  let minVector = new THREE.Vector3(minx, miny, minz);\n  let maxVector = new THREE.Vector3(maxx, maxy, maxz);\n  return new THREE.Box3(minVector, maxVector);\n};\n\n/* kmeans++ 选择初始聚类中心，每个聚类中心要离的相对较远 */\n\nconst getClosestDist = (point, kCentroids, dist) => {\n  let minDist = +Infinity;\n  let k = kCentroids.length;\n  for (let i = 0; i < k; i += 3) {\n    let centroid = extract(kCentroids, i);\n    let d = dist(centroid, point);\n    if (d < minDist) minDist = d;\n  }\n  return minDist;\n};\nconst initKppCentroids = (data, k, dist) => {\n  let kCentroids = [];\n  let dataLength = data.length;\n  let idx = Math.floor(Math.random() * (dataLength / 3));\n  kCentroids.push(data[idx * 3], data[idx * 3 + 1], data[idx * 3 + 2]);\n  let D = new Array(dataLength / 3);\n  for (let _ = 1; _ < k; _++) {\n    let total = 0;\n    for (let i = 0; i < dataLength; i += 3) {\n      let point = extract(data, i);\n      let idx = i / 3;\n      D[idx] = getClosestDist(point, kCentroids, dist);\n      total += D[idx];\n    }\n    total *= Math.random();\n    for (let i = 0; i < D.length; i++) {\n      total -= D[i];\n      if (total > 0) continue;\n      kCentroids.push(data[i * 3], data[i * 3 + 1], data[i * 3 + 2]);\n      break;\n    }\n  }\n  return kCentroids;\n};\n\n/* kmeans 算法包含的函数 */\n\n/**\n * API: loadData\n * @param {*} points\n * @returns data\n */\nconst loadData = points => {\n  let data = [];\n  if (Array.isArray(points)) {\n    points.forEach(p => {\n      let particals = p.geometry.attributes.position.array;\n      data.push(...particals);\n    });\n  } else data = points.geometry.attributes.position.array;\n  return data;\n};\nconst initKCentroids = (data, k) => {\n  let kCentroids = [];\n  let num = data.length / 3;\n  let idxSet = new Set();\n  while (idxSet.size < k) {\n    let idx = 3 * Math.floor(Math.random() * num);\n    if (idxSet.has(idx)) continue;\n    idxSet.add(idx);\n    kCentroids.push(data[idx], data[idx + 1], data[idx + 2]);\n  }\n  return kCentroids;\n};\nconst divideClusters = (data, kCentroids, dist) => {\n  let clusters = new Map();\n  let k = kCentroids.length,\n    datalength = data.length;\n  for (let i = 0; i < datalength; i += 3) {\n    let node = extract(data, i);\n    let clusterIdx = -1;\n    let minDist = +Infinity;\n    for (let j = 0; j < k; j += 3) {\n      let centroid = extract(kCentroids, j);\n      let distance = dist(centroid, node);\n      if (distance < minDist) {\n        minDist = distance;\n        clusterIdx = j / 3;\n      }\n    }\n    if (!clusters.get(clusterIdx)) clusters.set(clusterIdx, []);\n    clusters.get(clusterIdx).push(...node);\n  }\n  return clusters;\n};\nconst getKCentroids = clusters => {\n  let newKCentroids = [];\n  clusters.forEach((v, k) => {\n    let newCentroid = mean(v);\n    newKCentroids.push(...newCentroid);\n  });\n  return newKCentroids;\n};\nconst sse = (centroid, cluster, dist) => {\n  let l = cluster.length;\n  let res = 0;\n  for (let i = 0; i < l; i += 3) {\n    let p = extract(cluster, i);\n    res += dist(centroid, p) ** 2;\n  }\n  return res;\n};\nconst calVariance = (kCentroids, clusters, dist) => {\n  let sum = 0;\n  clusters.forEach((cluster, k) => {\n    let centroid = extract(kCentroids, k);\n    let SSE = sse(centroid, cluster, dist);\n    sum += SSE;\n  });\n  return sum;\n};\n\n/* DBSCAN 算法包含的函数 */\n\nconst identifyPoint = (point, epslon, minPts, octree) => {\n  let sphere = new THREE.Sphere(point, epslon);\n  let boundingBox = new THREE.Box3();\n  sphere.getBoundingBox(boundingBox);\n  let found = [];\n  octree.queryBySphere(sphere, boundingBox, found);\n  if (found.length >= minPts) return {\n    type: \"core\",\n    neighbors: found\n  };else if (found.length > 0) return {\n    type: \"border\",\n    neighbors: found\n  };else return {\n    type: \"noise\",\n    neighbors: found\n  };\n};\nconst distSchema = new Map([[\"euclidean\", euclideanDistance], [\"lu\", luDistance]]);\nconst methodSchema = new Map([[\"random\", initKCentroids], [\"kmeans++\", initKppCentroids]]);\n\n/**\n * API: clusterByCentroids\n * @param {*} data\n * @param {*} centroids\n * @param {*} distString\n * @returns clusters\n */\nconst clusterByCentroids = (data, centroids, distString = \"lu\") => {\n  let dist = distSchema.get(distString);\n  return divideClusters(data, centroids.flat(), dist);\n};\n\n/**\n * API: kMeans\n * @param {*} data\n * @param {*} k\n * @param {*} distString\n * @param {*} createCentString\n * @param {*} scene\n * @returns centroids and coresponding clusters\n */\nconst kMeans = (data, k, scene = null, distString = \"euclidean\",\n// 欧式距离\ncreateCentString = \"kmeans++\" // kmeans++初始聚类\n) => {\n  let dist = distSchema.get(distString);\n  let createCent = methodSchema.get(createCentString);\n  let centroids = createCent(data, k, dist);\n  let clusters = divideClusters(data, centroids, dist);\n  let newVar = calVariance(centroids, clusters, dist);\n  let oldVar = 1;\n  while (Math.abs(newVar - oldVar) > 1e-6) {\n    centroids = getKCentroids(clusters);\n    clusters = divideClusters(data, centroids, dist);\n    oldVar = newVar;\n    newVar = calVariance(centroids, clusters, dist);\n  }\n  // print clusters\n  if (scene) {\n    clusters.forEach((v, k) => {\n      const geometry = new THREE.BufferGeometry();\n      geometry.setAttribute(\"position\", new THREE.BufferAttribute(new Float32Array(v), 3));\n      let r = Math.floor(Math.random() * 256);\n      let g = Math.floor(Math.random() * 256);\n      let b = Math.floor(Math.random() * 256);\n      const material = new THREE.PointsMaterial({\n        color: `rgb(${r},${g},${b})`,\n        size: 0.4\n      });\n      const p = new THREE.Points(geometry, material);\n      scene.add(p);\n    });\n    for (let i = 0; i < centroids.length; i += 3) {\n      let centroid = extract(centroids, i);\n      let pointmesh = toSeePoint(new THREE.Vector3(centroid[0], centroid[1], centroid[2]));\n      scene.add(pointmesh);\n    }\n  }\n  return {\n    centroids,\n    clusters\n  };\n};\n\n/**\n * API: bikMeans\n * @param {*} data\n * @param {*} k\n * @param {*} distString\n * @param {*} createCentString\n * @param {*} scene\n * @returns clusters\n */\nconst bikMeans = (data, k, distString = \"euclidean\", createCentString = \"kmeans++\", scene = null) => {\n  let dist = distSchema.get(distString);\n  const clusters = [];\n  let centroid = mean(data);\n  let SSE = sse(centroid, data, dist);\n  let maxSSE = SSE,\n    maxidx = 0;\n  clusters.push({\n    points: data,\n    centroid: centroid,\n    sse: SSE\n  });\n  while (clusters.length < k) {\n    let cluster = clusters[maxidx];\n    let {\n      centroids: split_centroids,\n      clusters: split_clusters\n    } = kMeans(cluster.points, 2, distString, createCentString, scene);\n    let centroid1 = extract(split_centroids, 0),\n      centroid2 = extract(split_centroids, 3);\n    let points1 = split_clusters.get(0),\n      points2 = split_clusters.get(1);\n    let SSE1 = sse(centroid1, points1, dist),\n      SSE2 = sse(centroid2, points2, dist);\n    clusters.splice(maxidx, 1, {\n      points: points1,\n      centroid: centroid1,\n      sse: SSE1\n    }, {\n      points: points2,\n      centroid: centroid2,\n      sse: SSE2\n    }); // 这导致 clusters 数组长度 +1\n    // 重新寻找最大的 SSE\n    maxSSE = 0;\n    maxidx = -1;\n    clusters.forEach((cluster, index) => {\n      if (maxSSE < cluster.sse) {\n        maxSSE = cluster.sse;\n        maxidx = index;\n      }\n    });\n  }\n  return clusters;\n};\n\n/**\n * API: DBSCAN\n * @param {*} data\n * @param {*} epslon\n * @param {*} minPts\n * @returns 写的不好\n */\nconst DBSCAN = (data, epslon, minPts) => {\n  const box3 = getBoundingBox(data);\n  const n = minPts;\n  const octree = new Octree(box3, n);\n  const vectors = octree.buildFromPointCloud(data);\n  const stack = []; // js array to simulate a stack\n  const clusters = [];\n  const totalNum = vectors.length;\n  const unvisitedIndex = new Array(totalNum);\n  for (let i = 0; i < totalNum; i++) unvisitedIndex[i] = i;\n  while (unvisitedIndex.length > 0) {\n    // let isFirstPoint = true;\n    // 从未访问点中选取一个新点，默认为第一个\n    let idx = unvisitedIndex[0];\n    let new_point = vectors[idx];\n    new_point.visited = true;\n    unvisitedIndex.splice(unvisitedIndex.indexOf(idx), 1);\n    let cur_cluster = [new_point.x, new_point.y, new_point.z];\n    clusters.push(cur_cluster);\n    stack.push(idx); // 入栈，栈内存下标\n\n    // console.log(unvisitedIndex.length);\n\n    while (stack.length > 0) {\n      let cur_idx = stack.pop();\n      let cur_point = vectors[cur_idx];\n      cur_cluster.push(cur_point.x, cur_point.y, cur_point.z); // 加入聚类\n      unvisitedIndex.splice(unvisitedIndex.indexOf(cur_idx), 1); // 从未访问点中删除\n      let {\n        type,\n        neighbors\n      } = identifyPoint(cur_point, epslon, minPts, octree);\n      if (type === \"core\") {\n        neighbors.forEach(neighbor_point => {\n          if (neighbor_point.visited === false) {\n            neighbor_point.visited = true;\n            stack.push(neighbor_point.index); // 入栈\n          }\n        });\n      } /*else if (type === \"border\") {\n        neighbors.forEach((neighbor_point) => {\n          if (neighbor_point.visited === false) {\n            neighbor_point.visited = true;\n            if (isFirstPoint) {\n              stack.push(neighbor_point.index);\n              isFirstPoint = false;\n            }\n          }\n        });\n        } else if (type === \"noise\") {\n        }*/\n    }\n    // 此聚类结束，进入下一次循环\n    let cur_cluster_points_num = cur_cluster.length / 3;\n    if (cur_cluster_points_num > totalNum / 2) {\n      // 如果此聚类中点的个数超过总数的一半，即认为这就是树木的点云，剩下的全是噪声\n      return cur_cluster;\n    }\n  }\n  return clusters;\n};\n\n/**\n * API: Connected Component Label\n * @param {*} pcd\n * @param {*} r\n * @returns 写的不好\n */\n_c = DBSCAN;\nconst connectedComponent = (pcd, r) => {\n  const octree = new Octree(pcd.geometry.boundingBox, 10, 0);\n  console.time(\"build octree\");\n  const vectors = octree.buildFromPointCloud(pcd);\n  console.timeEnd(\"build octree\");\n  const stack = [];\n  const totalNum = vectors.length;\n  console.log(\"点云包含点的个数:\", totalNum);\n  const unvisitedIndex = new Array(totalNum);\n  for (let i = 0; i < totalNum; i++) unvisitedIndex[i] = i;\n  let sphere = new THREE.Sphere();\n  sphere.radius = r;\n  const clusters = [];\n  console.time(\"compute connected component\");\n  while (unvisitedIndex.length > 0) {\n    let idx = unvisitedIndex[0];\n    let new_point = vectors[idx];\n    new_point.visited = true;\n    unvisitedIndex.splice(unvisitedIndex.indexOf(idx), 1);\n    stack.push(idx); // 入栈，栈内存下标\n\n    let cur_cluster = [new_point.x, new_point.y, new_point.z];\n    clusters.push(cur_cluster);\n    while (stack.length > 0) {\n      let cur_idx = stack.pop();\n      let cur_point = vectors[cur_idx];\n      cur_cluster.push(cur_point.x, cur_point.y, cur_point.z); // 加入聚类\n      unvisitedIndex.splice(unvisitedIndex.indexOf(cur_idx), 1); // 从未访问点中删除\n      // look for its neighbors\n      sphere.center = cur_point;\n      let neighbors = octree.queryBySphere(sphere);\n      neighbors.forEach(neighbor => {\n        if (!neighbor.visited) {\n          neighbor.visited = true;\n          stack.push(neighbor.index); // 入栈\n        }\n      });\n    }\n    // stack is empty\n  }\n  console.timeEnd(\"compute connected component\");\n  return clusters;\n};\nexport { loadData, clusterByCentroids, kMeans, bikMeans, DBSCAN, connectedComponent };\nvar _c;\n$RefreshReg$(_c, \"DBSCAN\");","map":{"version":3,"names":["THREE","Octree","toSeePoint","extract","arr","index","euclideanDistance","n1","n2","Math","sqrt","luDistance","sum","mean","data","x","y","z","l","length","i","getBoundingBox","minx","Infinity","miny","minz","maxx","maxy","maxz","min","max","minVector","Vector3","maxVector","Box3","getClosestDist","point","kCentroids","dist","minDist","k","centroid","d","initKppCentroids","dataLength","idx","floor","random","push","D","Array","_","total","loadData","points","isArray","forEach","p","particals","geometry","attributes","position","array","initKCentroids","num","idxSet","Set","size","has","add","divideClusters","clusters","Map","datalength","node","clusterIdx","j","distance","get","set","getKCentroids","newKCentroids","v","newCentroid","sse","cluster","res","calVariance","SSE","identifyPoint","epslon","minPts","octree","sphere","Sphere","boundingBox","found","queryBySphere","type","neighbors","distSchema","methodSchema","clusterByCentroids","centroids","distString","flat","kMeans","scene","createCentString","createCent","newVar","oldVar","abs","BufferGeometry","setAttribute","BufferAttribute","Float32Array","r","g","b","material","PointsMaterial","color","Points","pointmesh","bikMeans","maxSSE","maxidx","split_centroids","split_clusters","centroid1","centroid2","points1","points2","SSE1","SSE2","splice","DBSCAN","box3","n","vectors","buildFromPointCloud","stack","totalNum","unvisitedIndex","new_point","visited","indexOf","cur_cluster","cur_idx","pop","cur_point","neighbor_point","cur_cluster_points_num","_c","connectedComponent","pcd","console","time","timeEnd","log","radius","center","neighbor","$RefreshReg$"],"sources":["C:/Users/21064/Desktop/frontend/src/lib/Cluster.js"],"sourcesContent":["import * as THREE from \"three\";\nimport { Octree } from \"./Octree\";\nimport { toSeePoint } from \"../utilities\";\n\n/* 工具函数 */\n\n// 从数组中获取一个三维坐标\nconst extract = (arr, index) => {\n  return [arr[index], arr[index + 1], arr[index + 2]];\n};\n\n// 计算两点间的欧氏距离\nconst euclideanDistance = (n1, n2) => {\n  return Math.sqrt(\n    (n1[0] - n2[0]) ** 2 + (n1[1] - n2[1]) ** 2 + (n1[2] - n2[2]) ** 2\n  );\n};\n\nconst luDistance = (n1, n2) => {\n  // centroid always be n1\n  let sum = (n1[0] - n2[0]) ** 2 + (n1[1] - n2[1]) ** 2;\n  return sum / n1[2] ** 3;\n};\n\n// 计算三维点集的平均点坐标\nconst mean = (data) => {\n  let x = 0,\n    y = 0,\n    z = 0;\n  let l = data.length;\n  for (let i = 0; i < l; i += 3) {\n    x += data[i];\n    y += data[i + 1];\n    z += data[i + 2];\n  }\n  x /= l / 3;\n  y /= l / 3;\n  z /= l / 3;\n  return [x, y, z];\n};\n\n// 计算点云的包围盒，点云以数组形式存储\nconst getBoundingBox = (data) => {\n  let l = data.length;\n  let minx = +Infinity,\n    miny = +Infinity,\n    minz = +Infinity,\n    maxx = -Infinity,\n    maxy = -Infinity,\n    maxz = -Infinity;\n  for (let i = 0; i < l; i += 3) {\n    minx = Math.min(data[i], minx);\n    miny = Math.min(data[i + 1], miny);\n    minz = Math.min(data[i + 2], minz);\n    maxx = Math.max(data[i], maxx);\n    maxy = Math.max(data[i + 1], maxy);\n    maxz = Math.max(data[i + 2], maxz);\n  }\n  let minVector = new THREE.Vector3(minx, miny, minz);\n  let maxVector = new THREE.Vector3(maxx, maxy, maxz);\n  return new THREE.Box3(minVector, maxVector);\n};\n\n/* kmeans++ 选择初始聚类中心，每个聚类中心要离的相对较远 */\n\nconst getClosestDist = (point, kCentroids, dist) => {\n  let minDist = +Infinity;\n  let k = kCentroids.length;\n  for (let i = 0; i < k; i += 3) {\n    let centroid = extract(kCentroids, i);\n    let d = dist(centroid, point);\n    if (d < minDist) minDist = d;\n  }\n  return minDist;\n};\n\nconst initKppCentroids = (data, k, dist) => {\n  let kCentroids = [];\n  let dataLength = data.length;\n  let idx = Math.floor(Math.random() * (dataLength / 3));\n  kCentroids.push(data[idx * 3], data[idx * 3 + 1], data[idx * 3 + 2]);\n  let D = new Array(dataLength / 3);\n  for (let _ = 1; _ < k; _++) {\n    let total = 0;\n    for (let i = 0; i < dataLength; i += 3) {\n      let point = extract(data, i);\n      let idx = i / 3;\n      D[idx] = getClosestDist(point, kCentroids, dist);\n      total += D[idx];\n    }\n    total *= Math.random();\n    for (let i = 0; i < D.length; i++) {\n      total -= D[i];\n      if (total > 0) continue;\n      kCentroids.push(data[i * 3], data[i * 3 + 1], data[i * 3 + 2]);\n      break;\n    }\n  }\n  return kCentroids;\n};\n\n/* kmeans 算法包含的函数 */\n\n/**\n * API: loadData\n * @param {*} points\n * @returns data\n */\nconst loadData = (points) => {\n  let data = [];\n  if (Array.isArray(points)) {\n    points.forEach((p) => {\n      let particals = p.geometry.attributes.position.array;\n      data.push(...particals);\n    });\n  } else data = points.geometry.attributes.position.array;\n  return data;\n};\n\nconst initKCentroids = (data, k) => {\n  let kCentroids = [];\n  let num = data.length / 3;\n  let idxSet = new Set();\n  while (idxSet.size < k) {\n    let idx = 3 * Math.floor(Math.random() * num);\n    if (idxSet.has(idx)) continue;\n    idxSet.add(idx);\n    kCentroids.push(data[idx], data[idx + 1], data[idx + 2]);\n  }\n  return kCentroids;\n};\n\nconst divideClusters = (data, kCentroids, dist) => {\n  let clusters = new Map();\n  let k = kCentroids.length,\n    datalength = data.length;\n  for (let i = 0; i < datalength; i += 3) {\n    let node = extract(data, i);\n    let clusterIdx = -1;\n    let minDist = +Infinity;\n    for (let j = 0; j < k; j += 3) {\n      let centroid = extract(kCentroids, j);\n      let distance = dist(centroid, node);\n      if (distance < minDist) {\n        minDist = distance;\n        clusterIdx = j / 3;\n      }\n    }\n    if (!clusters.get(clusterIdx)) clusters.set(clusterIdx, []);\n\n    clusters.get(clusterIdx).push(...node);\n  }\n  return clusters;\n};\n\nconst getKCentroids = (clusters) => {\n  let newKCentroids = [];\n  clusters.forEach((v, k) => {\n    let newCentroid = mean(v);\n    newKCentroids.push(...newCentroid);\n  });\n  return newKCentroids;\n};\n\nconst sse = (centroid, cluster, dist) => {\n  let l = cluster.length;\n  let res = 0;\n  for (let i = 0; i < l; i += 3) {\n    let p = extract(cluster, i);\n    res += dist(centroid, p) ** 2;\n  }\n  return res;\n};\n\nconst calVariance = (kCentroids, clusters, dist) => {\n  let sum = 0;\n  clusters.forEach((cluster, k) => {\n    let centroid = extract(kCentroids, k);\n    let SSE = sse(centroid, cluster, dist);\n    sum += SSE;\n  });\n  return sum;\n};\n\n/* DBSCAN 算法包含的函数 */\n\nconst identifyPoint = (point, epslon, minPts, octree) => {\n  let sphere = new THREE.Sphere(point, epslon);\n  let boundingBox = new THREE.Box3();\n  sphere.getBoundingBox(boundingBox);\n\n  let found = [];\n  octree.queryBySphere(sphere, boundingBox, found);\n\n  if (found.length >= minPts) return { type: \"core\", neighbors: found };\n  else if (found.length > 0) return { type: \"border\", neighbors: found };\n  else return { type: \"noise\", neighbors: found };\n};\n\nconst distSchema = new Map([\n  [\"euclidean\", euclideanDistance],\n  [\"lu\", luDistance],\n]);\n\nconst methodSchema = new Map([\n  [\"random\", initKCentroids],\n  [\"kmeans++\", initKppCentroids],\n]);\n\n/**\n * API: clusterByCentroids\n * @param {*} data\n * @param {*} centroids\n * @param {*} distString\n * @returns clusters\n */\nconst clusterByCentroids = (data, centroids, distString = \"lu\") => {\n  let dist = distSchema.get(distString);\n  return divideClusters(data, centroids.flat(), dist);\n};\n\n/**\n * API: kMeans\n * @param {*} data\n * @param {*} k\n * @param {*} distString\n * @param {*} createCentString\n * @param {*} scene\n * @returns centroids and coresponding clusters\n */\nconst kMeans = (\n  data,\n  k,\n  scene = null,\n  distString = \"euclidean\", // 欧式距离\n  createCentString = \"kmeans++\" // kmeans++初始聚类\n) => {\n  let dist = distSchema.get(distString);\n  let createCent = methodSchema.get(createCentString);\n  let centroids = createCent(data, k, dist);\n  let clusters = divideClusters(data, centroids, dist);\n  let newVar = calVariance(centroids, clusters, dist);\n  let oldVar = 1;\n\n  while (Math.abs(newVar - oldVar) > 1e-6) {\n    centroids = getKCentroids(clusters);\n    clusters = divideClusters(data, centroids, dist);\n    oldVar = newVar;\n    newVar = calVariance(centroids, clusters, dist);\n  }\n  // print clusters\n  if (scene) {\n    clusters.forEach((v, k) => {\n      const geometry = new THREE.BufferGeometry();\n      geometry.setAttribute(\n        \"position\",\n        new THREE.BufferAttribute(new Float32Array(v), 3)\n      );\n      let r = Math.floor(Math.random() * 256);\n      let g = Math.floor(Math.random() * 256);\n      let b = Math.floor(Math.random() * 256);\n      const material = new THREE.PointsMaterial({\n        color: `rgb(${r},${g},${b})`,\n        size: 0.4,\n      });\n      const p = new THREE.Points(geometry, material);\n      scene.add(p);\n    });\n\n    for (let i = 0; i < centroids.length; i += 3) {\n      let centroid = extract(centroids, i);\n      let pointmesh = toSeePoint(\n        new THREE.Vector3(centroid[0], centroid[1], centroid[2])\n      );\n      scene.add(pointmesh);\n    }\n  }\n  return { centroids, clusters };\n};\n\n/**\n * API: bikMeans\n * @param {*} data\n * @param {*} k\n * @param {*} distString\n * @param {*} createCentString\n * @param {*} scene\n * @returns clusters\n */\nconst bikMeans = (\n  data,\n  k,\n  distString = \"euclidean\",\n  createCentString = \"kmeans++\",\n  scene = null\n) => {\n  let dist = distSchema.get(distString);\n  const clusters = [];\n  let centroid = mean(data);\n  let SSE = sse(centroid, data, dist);\n  let maxSSE = SSE,\n    maxidx = 0;\n  clusters.push({ points: data, centroid: centroid, sse: SSE });\n\n  while (clusters.length < k) {\n    let cluster = clusters[maxidx];\n    let { centroids: split_centroids, clusters: split_clusters } = kMeans(\n      cluster.points,\n      2,\n      distString,\n      createCentString,\n      scene\n    );\n\n    let centroid1 = extract(split_centroids, 0),\n      centroid2 = extract(split_centroids, 3);\n    let points1 = split_clusters.get(0),\n      points2 = split_clusters.get(1);\n    let SSE1 = sse(centroid1, points1, dist),\n      SSE2 = sse(centroid2, points2, dist);\n    clusters.splice(\n      maxidx,\n      1,\n      { points: points1, centroid: centroid1, sse: SSE1 },\n      { points: points2, centroid: centroid2, sse: SSE2 }\n    ); // 这导致 clusters 数组长度 +1\n    // 重新寻找最大的 SSE\n    maxSSE = 0;\n    maxidx = -1;\n    clusters.forEach((cluster, index) => {\n      if (maxSSE < cluster.sse) {\n        maxSSE = cluster.sse;\n        maxidx = index;\n      }\n    });\n  }\n  return clusters;\n};\n\n/**\n * API: DBSCAN\n * @param {*} data\n * @param {*} epslon\n * @param {*} minPts\n * @returns 写的不好\n */\nconst DBSCAN = (data, epslon, minPts) => {\n  const box3 = getBoundingBox(data);\n  const n = minPts;\n  const octree = new Octree(box3, n);\n\n  const vectors = octree.buildFromPointCloud(data);\n  const stack = []; // js array to simulate a stack\n  const clusters = [];\n  const totalNum = vectors.length;\n  const unvisitedIndex = new Array(totalNum);\n  for (let i = 0; i < totalNum; i++) unvisitedIndex[i] = i;\n\n  while (unvisitedIndex.length > 0) {\n    // let isFirstPoint = true;\n    // 从未访问点中选取一个新点，默认为第一个\n    let idx = unvisitedIndex[0];\n    let new_point = vectors[idx];\n\n    new_point.visited = true;\n    unvisitedIndex.splice(unvisitedIndex.indexOf(idx), 1);\n\n    let cur_cluster = [new_point.x, new_point.y, new_point.z];\n    clusters.push(cur_cluster);\n    stack.push(idx); // 入栈，栈内存下标\n\n    // console.log(unvisitedIndex.length);\n\n    while (stack.length > 0) {\n      let cur_idx = stack.pop();\n      let cur_point = vectors[cur_idx];\n      cur_cluster.push(cur_point.x, cur_point.y, cur_point.z); // 加入聚类\n      unvisitedIndex.splice(unvisitedIndex.indexOf(cur_idx), 1); // 从未访问点中删除\n      let { type, neighbors } = identifyPoint(\n        cur_point,\n        epslon,\n        minPts,\n        octree\n      );\n\n      if (type === \"core\") {\n        neighbors.forEach((neighbor_point) => {\n          if (neighbor_point.visited === false) {\n            neighbor_point.visited = true;\n            stack.push(neighbor_point.index); // 入栈\n          }\n        });\n      } /*else if (type === \"border\") {\n        neighbors.forEach((neighbor_point) => {\n          if (neighbor_point.visited === false) {\n            neighbor_point.visited = true;\n            if (isFirstPoint) {\n              stack.push(neighbor_point.index);\n              isFirstPoint = false;\n            }\n          }\n        });\n      } else if (type === \"noise\") {\n      }*/\n    }\n    // 此聚类结束，进入下一次循环\n    let cur_cluster_points_num = cur_cluster.length / 3;\n    if (cur_cluster_points_num > totalNum / 2) {\n      // 如果此聚类中点的个数超过总数的一半，即认为这就是树木的点云，剩下的全是噪声\n      return cur_cluster;\n    }\n  }\n  return clusters;\n};\n\n/**\n * API: Connected Component Label\n * @param {*} pcd\n * @param {*} r\n * @returns 写的不好\n */\nconst connectedComponent = (pcd, r) => {\n  const octree = new Octree(pcd.geometry.boundingBox, 10, 0);\n\n  console.time(\"build octree\");\n  const vectors = octree.buildFromPointCloud(pcd);\n  console.timeEnd(\"build octree\");\n\n  const stack = [];\n  const totalNum = vectors.length;\n\n  console.log(\"点云包含点的个数:\", totalNum);\n\n  const unvisitedIndex = new Array(totalNum);\n  for (let i = 0; i < totalNum; i++) unvisitedIndex[i] = i;\n\n  let sphere = new THREE.Sphere();\n  sphere.radius = r;\n\n  const clusters = [];\n\n  console.time(\"compute connected component\");\n  while (unvisitedIndex.length > 0) {\n    let idx = unvisitedIndex[0];\n    let new_point = vectors[idx];\n    new_point.visited = true;\n    unvisitedIndex.splice(unvisitedIndex.indexOf(idx), 1);\n    stack.push(idx); // 入栈，栈内存下标\n\n    let cur_cluster = [new_point.x, new_point.y, new_point.z];\n    clusters.push(cur_cluster);\n\n    while (stack.length > 0) {\n      let cur_idx = stack.pop();\n      let cur_point = vectors[cur_idx];\n      cur_cluster.push(cur_point.x, cur_point.y, cur_point.z); // 加入聚类\n      unvisitedIndex.splice(unvisitedIndex.indexOf(cur_idx), 1); // 从未访问点中删除\n      // look for its neighbors\n      sphere.center = cur_point;\n      let neighbors = octree.queryBySphere(sphere);\n\n      neighbors.forEach((neighbor) => {\n        if (!neighbor.visited) {\n          neighbor.visited = true;\n          stack.push(neighbor.index); // 入栈\n        }\n      });\n    }\n    // stack is empty\n  }\n  console.timeEnd(\"compute connected component\");\n  return clusters;\n};\n\nexport {\n  loadData,\n  clusterByCentroids,\n  kMeans,\n  bikMeans,\n  DBSCAN,\n  connectedComponent,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}