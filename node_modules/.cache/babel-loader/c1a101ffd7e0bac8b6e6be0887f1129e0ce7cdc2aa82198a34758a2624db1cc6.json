{"ast":null,"code":"import * as THREE from \"three\";\nclass Octree {\n  constructor(box3, n, depth) {\n    this.box = box3;\n    this.capacity = n;\n    this.divided = false;\n    this.transforms = [];\n    this.children = [];\n    this.depth = depth;\n  }\n  subdivide() {\n    const {\n      box,\n      capacity,\n      depth\n    } = this;\n    let size = new THREE.Vector3().subVectors(box.max, box.min).divideScalar(2);\n    let arr = [[0, 0, 0], [size.x, 0, 0], [0, 0, size.z], [size.x, 0, size.z], [0, size.y, 0], [size.x, size.y, 0], [0, size.y, size.z], [size.x, size.y, size.z]];\n    for (let i = 0; i < 8; i++) {\n      let min = new THREE.Vector3(box.min.x + arr[i][0], box.min.y + arr[i][1], box.min.z + arr[i][2]);\n      let max = new THREE.Vector3().addVectors(min, size);\n      let newbox = new THREE.Box3(min, max);\n      this.children.push(new Octree(newbox, capacity, depth + 1));\n    }\n    this.divided = true;\n  }\n  insert(transform) {\n    const {\n      box,\n      transforms,\n      capacity,\n      divided,\n      children\n    } = this;\n    if (!box.containsPoint(new THREE.Vector3().setFromMatrixPosition(transform))) return false;\n    if (transforms.length < capacity) {\n      transforms.push(transform);\n      return true;\n    } else {\n      if (!divided) this.subdivide();\n      for (let i = 0; i < children.length; i++) {\n        if (children[i].insert(transform)) return true;\n      }\n    }\n  }\n  queryByBox(boxRange, found = []) {\n    if (!this.box.intersectsBox(boxRange)) {\n      return found;\n    } else {\n      for (let transform of this.transforms) {\n        if (boxRange.containsPoint(new THREE.Vector3().setFromMatrixPosition(transform))) {\n          found.push(transform);\n        }\n      }\n      if (this.divided) {\n        this.children.forEach(child => {\n          child.queryByBox(boxRange, found);\n        });\n      }\n      return found;\n    }\n  }\n  queryBySphere(sphereRange, boundingBox = sphereRange.getBoundingBox(new THREE.Box3()), found = []) {\n    if (!this.box.intersectsBox(boundingBox)) {\n      return found;\n    } else {\n      for (let transform of this.transforms) {\n        if (sphereRange.containsPoint(new THREE.Vector3().setFromMatrixPosition(transform))) {\n          found.push(transform);\n        }\n      }\n      if (this.divided) {\n        this.children.forEach(child => {\n          child.queryBySphere(sphereRange, boundingBox, found);\n        });\n      }\n      return found;\n    }\n  }\n  queryByFrustum(frustum, found = []) {\n    if (!frustum.intersectsBox(this.box)) {\n      return found;\n    } else {\n      for (let transform of this.transforms) {\n        if (frustum.containsPoint(new THREE.Vector3().setFromMatrixPosition(transform))) {\n          found.push(transform);\n        }\n      }\n      if (this.divided) {\n        this.children.forEach(child => {\n          child.queryByFrustum(frustum, found);\n        });\n      }\n      return found;\n    }\n  }\n  display(scene) {\n    // 叶子结点\n    if (!this.divided && this.transforms.length > 0) {\n      scene.add(new THREE.Box3Helper(this.box, 0x00ff00));\n      return;\n    }\n    this.children.forEach(child => {\n      child.display(scene);\n    });\n  }\n}\nexport { Octree };","map":{"version":3,"names":["THREE","Octree","constructor","box3","n","depth","box","capacity","divided","transforms","children","subdivide","size","Vector3","subVectors","max","min","divideScalar","arr","x","z","y","i","addVectors","newbox","Box3","push","insert","transform","containsPoint","setFromMatrixPosition","length","queryByBox","boxRange","found","intersectsBox","forEach","child","queryBySphere","sphereRange","boundingBox","getBoundingBox","queryByFrustum","frustum","display","scene","add","Box3Helper"],"sources":["C:/Users/21064/Desktop/frontend/src/lib/Octree.js"],"sourcesContent":["import * as THREE from \"three\";\n\nclass Octree {\n  constructor(box3, n, depth) {\n    this.box = box3;\n    this.capacity = n;\n    this.divided = false;\n    this.transforms = [];\n    this.children = [];\n    this.depth = depth;\n  }\n\n  subdivide() {\n    const { box, capacity, depth } = this;\n    let size = new THREE.Vector3().subVectors(box.max, box.min).divideScalar(2);\n    let arr = [\n      [0, 0, 0],\n      [size.x, 0, 0],\n      [0, 0, size.z],\n      [size.x, 0, size.z],\n      [0, size.y, 0],\n      [size.x, size.y, 0],\n      [0, size.y, size.z],\n      [size.x, size.y, size.z],\n    ];\n    for (let i = 0; i < 8; i++) {\n      let min = new THREE.Vector3(\n        box.min.x + arr[i][0],\n        box.min.y + arr[i][1],\n        box.min.z + arr[i][2]\n      );\n      let max = new THREE.Vector3().addVectors(min, size);\n      let newbox = new THREE.Box3(min, max);\n      this.children.push(new Octree(newbox, capacity, depth + 1));\n    }\n    this.divided = true;\n  }\n\n  insert(transform) {\n    const { box, transforms, capacity, divided, children } = this;\n    if (\n      !box.containsPoint(new THREE.Vector3().setFromMatrixPosition(transform))\n    )\n      return false;\n    if (transforms.length < capacity) {\n      transforms.push(transform);\n      return true;\n    } else {\n      if (!divided) this.subdivide();\n      for (let i = 0; i < children.length; i++) {\n        if (children[i].insert(transform)) return true;\n      }\n    }\n  }\n\n  queryByBox(boxRange, found = []) {\n    if (!this.box.intersectsBox(boxRange)) {\n      return found;\n    } else {\n      for (let transform of this.transforms) {\n        if (\n          boxRange.containsPoint(\n            new THREE.Vector3().setFromMatrixPosition(transform)\n          )\n        ) {\n          found.push(transform);\n        }\n      }\n      if (this.divided) {\n        this.children.forEach((child) => {\n          child.queryByBox(boxRange, found);\n        });\n      }\n      return found;\n    }\n  }\n\n  queryBySphere(\n    sphereRange,\n    boundingBox = sphereRange.getBoundingBox(new THREE.Box3()),\n    found = []\n  ) {\n    if (!this.box.intersectsBox(boundingBox)) {\n      return found;\n    } else {\n      for (let transform of this.transforms) {\n        if (\n          sphereRange.containsPoint(\n            new THREE.Vector3().setFromMatrixPosition(transform)\n          )\n        ) {\n          found.push(transform);\n        }\n      }\n      if (this.divided) {\n        this.children.forEach((child) => {\n          child.queryBySphere(sphereRange, boundingBox, found);\n        });\n      }\n      return found;\n    }\n  }\n\n  queryByFrustum(frustum, found = []) {\n    if (!frustum.intersectsBox(this.box)) {\n      return found;\n    } else {\n      for (let transform of this.transforms) {\n        if (\n          frustum.containsPoint(\n            new THREE.Vector3().setFromMatrixPosition(transform)\n          )\n        ) {\n          found.push(transform);\n        }\n      }\n      if (this.divided) {\n        this.children.forEach((child) => {\n          child.queryByFrustum(frustum, found);\n        });\n      }\n      return found;\n    }\n  }\n\n  display(scene) {\n    // 叶子结点\n    if (!this.divided && this.transforms.length > 0) {\n      scene.add(new THREE.Box3Helper(this.box, 0x00ff00));\n      return;\n    }\n    this.children.forEach((child) => {\n      child.display(scene);\n    });\n  }\n}\n\nexport { Octree };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}