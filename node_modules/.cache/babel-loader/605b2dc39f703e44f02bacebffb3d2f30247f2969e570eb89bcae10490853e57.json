{"ast":null,"code":"import { BufferGeometry } from \"three/src/core/BufferGeometry.js\";\nimport { Float32BufferAttribute } from \"three/src/core/BufferAttribute.js\";\nimport * as Curves from \"three/src/extras/curves/Curves.js\";\nimport { Vector2 } from \"three/src/math/Vector2.js\";\nimport { Vector3 } from \"three/src/math/Vector3.js\";\nclass BranchTubeGeometry extends BufferGeometry {\n  constructor(path = new Curves[\"QuadraticBezierCurve3\"](new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false, shrink = 0.9, sampleOffset) {\n    super();\n    this.type = \"BranchTubeGeometry\";\n    this.parameters = {\n      path: path,\n      tubularSegments: tubularSegments,\n      radius: radius,\n      radialSegments: radialSegments,\n      closed: closed,\n      shrink: shrink,\n      sampleOffset: sampleOffset\n    };\n    const frames = path.computeFrenetFrames(tubularSegments, closed);\n\n    // expose internals\n\n    this.tangents = frames.tangents;\n    this.normals = frames.normals;\n    this.binormals = frames.binormals;\n\n    // helper variables\n\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    let P = new Vector3();\n\n    // buffer\n\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    // create buffer data\n\n    generateBufferData();\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n\n    // functions\n\n    function generateBufferData() {\n      let r = radius;\n      for (let i = 0; i < tubularSegments; i++) {\n        generateSegment(i, r);\n        r -= shrink;\n      }\n\n      // if the geometry is not closed, generate the last row of vertices and normals\n      // at the regular position on the given path\n      //\n      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n      generateSegment(closed === false ? tubularSegments : 0, r);\n\n      // uvs are generated in a separate function.\n      // this makes it easy compute correct values for closed geometries\n\n      generateUVs();\n\n      // finally create faces\n\n      generateIndices();\n    }\n    function generateSegment(i, r = radius) {\n      // we use getPointAt to sample evenly distributed points from the given path\n\n      P = path.getPointAt(i / tubularSegments, P).add(new Vector3().randomDirection().multiplyScalar(sampleOffset));\n\n      // retrieve corresponding normal and binormal\n\n      const N = frames.normals[i];\n      const B = frames.binormals[i];\n\n      // generate normals and vertices for the current segment\n\n      for (let j = 0; j <= radialSegments; j++) {\n        const v = j / radialSegments * Math.PI * 2;\n        const sin = Math.sin(v);\n        const cos = -Math.cos(v);\n\n        // normal\n\n        normal.x = cos * N.x + sin * B.x;\n        normal.y = cos * N.y + sin * B.y;\n        normal.z = cos * N.z + sin * B.z;\n        normal.normalize();\n        normals.push(normal.x, normal.y, normal.z);\n\n        // vertex\n\n        vertex.x = P.x + r * normal.x;\n        vertex.y = P.y + r * normal.y;\n        vertex.z = P.z + r * normal.z;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    }\n    function generateIndices() {\n      for (let j = 1; j <= tubularSegments; j++) {\n        for (let i = 1; i <= radialSegments; i++) {\n          const a = (radialSegments + 1) * (j - 1) + (i - 1);\n          const b = (radialSegments + 1) * j + (i - 1);\n          const c = (radialSegments + 1) * j + i;\n          const d = (radialSegments + 1) * (j - 1) + i;\n\n          // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n    }\n    function generateUVs() {\n      for (let i = 0; i <= tubularSegments; i++) {\n        for (let j = 0; j <= radialSegments; j++) {\n          uv.y = i / tubularSegments;\n          uv.x = j / radialSegments;\n          uvs.push(uv.x, uv.y);\n        }\n      }\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.path = this.parameters.path.toJSON();\n    return data;\n  }\n  static fromJSON(data) {\n    // This only works for built-in curves (e.g. CatmullRomCurve3).\n    // User defined curves or instances of CurvePath will not be deserialized.\n    return new BranchTubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed, data.shrink);\n  }\n}\nexport { BranchTubeGeometry };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","Curves","Vector2","Vector3","BranchTubeGeometry","constructor","path","tubularSegments","radius","radialSegments","closed","shrink","sampleOffset","type","parameters","frames","computeFrenetFrames","tangents","normals","binormals","vertex","normal","uv","P","vertices","uvs","indices","generateBufferData","setIndex","setAttribute","r","i","generateSegment","generateUVs","generateIndices","getPointAt","add","randomDirection","multiplyScalar","N","B","j","v","Math","PI","sin","cos","x","y","z","normalize","push","a","b","c","d","copy","source","Object","assign","toJSON","data","fromJSON"],"sources":["C:/Users/21064/Desktop/frontend/src/lib/BranchTubeGeometry.js"],"sourcesContent":["import { BufferGeometry } from \"three/src/core/BufferGeometry.js\";\nimport { Float32BufferAttribute } from \"three/src/core/BufferAttribute.js\";\nimport * as Curves from \"three/src/extras/curves/Curves.js\";\nimport { Vector2 } from \"three/src/math/Vector2.js\";\nimport { Vector3 } from \"three/src/math/Vector3.js\";\n\nclass BranchTubeGeometry extends BufferGeometry {\n  constructor(\n    path = new Curves[\"QuadraticBezierCurve3\"](\n      new Vector3(-1, -1, 0),\n      new Vector3(-1, 1, 0),\n      new Vector3(1, 1, 0)\n    ),\n    tubularSegments = 64,\n    radius = 1,\n    radialSegments = 8,\n    closed = false,\n    shrink = 0.9,\n    sampleOffset\n  ) {\n    super();\n\n    this.type = \"BranchTubeGeometry\";\n\n    this.parameters = {\n      path: path,\n      tubularSegments: tubularSegments,\n      radius: radius,\n      radialSegments: radialSegments,\n      closed: closed,\n      shrink: shrink,\n      sampleOffset: sampleOffset,\n    };\n\n    const frames = path.computeFrenetFrames(tubularSegments, closed);\n\n    // expose internals\n\n    this.tangents = frames.tangents;\n    this.normals = frames.normals;\n    this.binormals = frames.binormals;\n\n    // helper variables\n\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    let P = new Vector3();\n\n    // buffer\n\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    // create buffer data\n\n    generateBufferData();\n\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n\n    // functions\n\n    function generateBufferData() {\n      let r = radius;\n      for (let i = 0; i < tubularSegments; i++) {\n        generateSegment(i, r);\n        r -= shrink;\n      }\n\n      // if the geometry is not closed, generate the last row of vertices and normals\n      // at the regular position on the given path\n      //\n      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n      generateSegment(closed === false ? tubularSegments : 0, r);\n\n      // uvs are generated in a separate function.\n      // this makes it easy compute correct values for closed geometries\n\n      generateUVs();\n\n      // finally create faces\n\n      generateIndices();\n    }\n\n    function generateSegment(i, r = radius) {\n      // we use getPointAt to sample evenly distributed points from the given path\n\n      P = path\n        .getPointAt(i / tubularSegments, P)\n        .add(new Vector3().randomDirection().multiplyScalar(sampleOffset));\n\n      // retrieve corresponding normal and binormal\n\n      const N = frames.normals[i];\n      const B = frames.binormals[i];\n\n      // generate normals and vertices for the current segment\n\n      for (let j = 0; j <= radialSegments; j++) {\n        const v = (j / radialSegments) * Math.PI * 2;\n\n        const sin = Math.sin(v);\n        const cos = -Math.cos(v);\n\n        // normal\n\n        normal.x = cos * N.x + sin * B.x;\n        normal.y = cos * N.y + sin * B.y;\n        normal.z = cos * N.z + sin * B.z;\n        normal.normalize();\n\n        normals.push(normal.x, normal.y, normal.z);\n\n        // vertex\n\n        vertex.x = P.x + r * normal.x;\n        vertex.y = P.y + r * normal.y;\n        vertex.z = P.z + r * normal.z;\n\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    }\n\n    function generateIndices() {\n      for (let j = 1; j <= tubularSegments; j++) {\n        for (let i = 1; i <= radialSegments; i++) {\n          const a = (radialSegments + 1) * (j - 1) + (i - 1);\n          const b = (radialSegments + 1) * j + (i - 1);\n          const c = (radialSegments + 1) * j + i;\n          const d = (radialSegments + 1) * (j - 1) + i;\n\n          // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n    }\n\n    function generateUVs() {\n      for (let i = 0; i <= tubularSegments; i++) {\n        for (let j = 0; j <= radialSegments; j++) {\n          uv.y = i / tubularSegments;\n          uv.x = j / radialSegments;\n\n          uvs.push(uv.x, uv.y);\n        }\n      }\n    }\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    this.parameters = Object.assign({}, source.parameters);\n\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n\n    data.path = this.parameters.path.toJSON();\n\n    return data;\n  }\n\n  static fromJSON(data) {\n    // This only works for built-in curves (e.g. CatmullRomCurve3).\n    // User defined curves or instances of CurvePath will not be deserialized.\n    return new BranchTubeGeometry(\n      new Curves[data.path.type]().fromJSON(data.path),\n      data.tubularSegments,\n      data.radius,\n      data.radialSegments,\n      data.closed,\n      data.shrink\n    );\n  }\n}\n\nexport { BranchTubeGeometry };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}